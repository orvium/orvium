/* tslint:disable */
/* eslint-disable */
/**
 * REST API
 * The REST API is used for all API interactions with DataCite services.
 *
 * The version of the OpenAPI document: 2.3.0
 * Contact: support@datacite.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Represents an activity for an event within DataCite systems.
 * @export
 * @interface Activity
 */
export interface Activity {
    /**
     * 
     * @type {ActivityData}
     * @memberof Activity
     */
    'data'?: ActivityData;
}
/**
 * 
 * @export
 * @interface ActivityData
 */
export interface ActivityData {
    /**
     * 
     * @type {string}
     * @memberof ActivityData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityData
     */
    'type'?: string;
    /**
     * 
     * @type {ActivityDataAttributes}
     * @memberof ActivityData
     */
    'attributes'?: ActivityDataAttributes;
}
/**
 * 
 * @export
 * @interface ActivityDataAttributes
 */
export interface ActivityDataAttributes {
    /**
     * 
     * @type {string}
     * @memberof ActivityDataAttributes
     */
    'prov:wasGeneratedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityDataAttributes
     */
    'prov:generatedAtTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityDataAttributes
     */
    'prov:wasDerivedFrom'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityDataAttributes
     */
    'prov:wasAttributedTo'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityDataAttributes
     */
    'action'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActivityDataAttributes
     */
    'version'?: number;
    /**
     * 
     * @type {object}
     * @memberof ActivityDataAttributes
     */
    'changes'?: object;
}
/**
 * 
 * @export
 * @interface Client
 */
export interface Client {
    /**
     * 
     * @type {ClientData}
     * @memberof Client
     */
    'data'?: ClientData;
}
/**
 * 
 * @export
 * @interface ClientData
 */
export interface ClientData {
    /**
     * 
     * @type {string}
     * @memberof ClientData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientData
     */
    'type'?: string;
    /**
     * 
     * @type {ClientDataAttributes}
     * @memberof ClientData
     */
    'attributes'?: ClientDataAttributes;
}
/**
 * 
 * @export
 * @interface ClientDataAttributes
 */
export interface ClientDataAttributes {
    /**
     * 
     * @type {string}
     * @memberof ClientDataAttributes
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDataAttributes
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDataAttributes
     */
    'contactName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDataAttributes
     */
    'contactEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDataAttributes
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDataAttributes
     */
    'domains'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDataAttributes
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDataAttributes
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDataAttributes
     */
    'updated'?: string;
}
/**
 * 
 * @export
 * @interface ClientPrefix
 */
export interface ClientPrefix {
    /**
     * 
     * @type {ClientPrefixData}
     * @memberof ClientPrefix
     */
    'data'?: ClientPrefixData;
}
/**
 * 
 * @export
 * @interface ClientPrefixData
 */
export interface ClientPrefixData {
    /**
     * 
     * @type {string}
     * @memberof ClientPrefixData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientPrefixData
     */
    'type'?: string;
    /**
     * 
     * @type {ClientPrefixDataAttributes}
     * @memberof ClientPrefixData
     */
    'attributes'?: ClientPrefixDataAttributes;
}
/**
 * 
 * @export
 * @interface ClientPrefixDataAttributes
 */
export interface ClientPrefixDataAttributes {
    /**
     * 
     * @type {string}
     * @memberof ClientPrefixDataAttributes
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientPrefixDataAttributes
     */
    'updated'?: string;
}
/**
 * Represents a DOI and provides access to metadata attributes, further schema specific information can be found at https://schema.datacite.org
 * @export
 * @interface Doi
 */
export interface Doi {
    /**
     * 
     * @type {DoiData}
     * @memberof Doi
     */
    'data'?: DoiData;
}
/**
 * 
 * @export
 * @interface DoiData
 */
export interface DoiData {
    /**
     * 
     * @type {string}
     * @memberof DoiData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiData
     */
    'type'?: string;
    /**
     * 
     * @type {DoiDataAttributes}
     * @memberof DoiData
     */
    'attributes'?: DoiDataAttributes;
}
/**
 * 
 * @export
 * @interface DoiDataAttributes
 */
export interface DoiDataAttributes {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributes
     */
    'doi'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributes
     */
    'prefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributes
     */
    'suffix'?: string;
    /**
     * Can be set to trigger a DOI state change.
     * @type {string}
     * @memberof DoiDataAttributes
     */
    'event'?: DoiDataAttributesEventEnum;
    /**
     * 
     * @type {Array<DoiDataAttributesIdentifiersInner>}
     * @memberof DoiDataAttributes
     */
    'identifiers'?: Array<DoiDataAttributesIdentifiersInner>;
    /**
     * 
     * @type {Array<DoiDataAttributesCreatorsInner>}
     * @memberof DoiDataAttributes
     */
    'creators'?: Array<DoiDataAttributesCreatorsInner>;
    /**
     * 
     * @type {Array<DoiDataAttributesTitlesInner>}
     * @memberof DoiDataAttributes
     */
    'titles'?: Array<DoiDataAttributesTitlesInner>;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributes
     */
    'publisher'?: string;
    /**
     * 
     * @type {DoiDataAttributesContainer}
     * @memberof DoiDataAttributes
     */
    'container'?: DoiDataAttributesContainer;
    /**
     * 
     * @type {number}
     * @memberof DoiDataAttributes
     */
    'publicationYear'?: number;
    /**
     * 
     * @type {Array<DoiDataAttributesSubjectsInner>}
     * @memberof DoiDataAttributes
     */
    'subjects'?: Array<DoiDataAttributesSubjectsInner>;
    /**
     * 
     * @type {Array<DoiDataAttributesContributorsInner>}
     * @memberof DoiDataAttributes
     */
    'contributors'?: Array<DoiDataAttributesContributorsInner>;
    /**
     * 
     * @type {Array<DoiDataAttributesDatesInner>}
     * @memberof DoiDataAttributes
     */
    'dates'?: Array<DoiDataAttributesDatesInner>;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributes
     */
    'language'?: string;
    /**
     * 
     * @type {DoiDataAttributesTypes}
     * @memberof DoiDataAttributes
     */
    'types'?: DoiDataAttributesTypes;
    /**
     * 
     * @type {Array<DoiDataAttributesRelatedIdentifiersInner>}
     * @memberof DoiDataAttributes
     */
    'relatedIdentifiers'?: Array<DoiDataAttributesRelatedIdentifiersInner>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DoiDataAttributes
     */
    'sizes'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DoiDataAttributes
     */
    'formats'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributes
     */
    'version'?: string;
    /**
     * 
     * @type {Array<DoiDataAttributesRightsListInner>}
     * @memberof DoiDataAttributes
     */
    'rightsList'?: Array<DoiDataAttributesRightsListInner>;
    /**
     * 
     * @type {Array<DoiDataAttributesDescriptionsInner>}
     * @memberof DoiDataAttributes
     */
    'descriptions'?: Array<DoiDataAttributesDescriptionsInner>;
    /**
     * 
     * @type {Array<DoiDataAttributesGeoLocationsInner>}
     * @memberof DoiDataAttributes
     */
    'geoLocations'?: Array<DoiDataAttributesGeoLocationsInner>;
    /**
     * 
     * @type {Array<DoiDataAttributesFundingReferencesInner>}
     * @memberof DoiDataAttributes
     */
    'fundingReferences'?: Array<DoiDataAttributesFundingReferencesInner>;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributes
     */
    'url'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DoiDataAttributes
     */
    'contentUrl'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DoiDataAttributes
     */
    'metadataVersion'?: number;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributes
     */
    'schemaVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributes
     */
    'source'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DoiDataAttributes
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributes
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributes
     */
    'reason'?: string;
    /**
     * 
     * @type {DoiDataAttributesLandingPage}
     * @memberof DoiDataAttributes
     */
    'landingPage'?: DoiDataAttributesLandingPage;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributes
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributes
     */
    'registered'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributes
     */
    'updated'?: string;
}

export const DoiDataAttributesEventEnum = {
    Publish: 'publish',
    Register: 'register',
    Hide: 'hide'
} as const;

export type DoiDataAttributesEventEnum = typeof DoiDataAttributesEventEnum[keyof typeof DoiDataAttributesEventEnum];

/**
 * 
 * @export
 * @interface DoiDataAttributesContainer
 */
export interface DoiDataAttributesContainer {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesContainer
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesContainer
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesContainer
     */
    'identifierType'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesContainer
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesContainer
     */
    'volume'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesContainer
     */
    'issue'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesContainer
     */
    'firstPage'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesContainer
     */
    'lastPage'?: string;
}
/**
 * 
 * @export
 * @interface DoiDataAttributesContributorsInner
 */
export interface DoiDataAttributesContributorsInner {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesContributorsInner
     */
    'nameType'?: string;
    /**
     * 
     * @type {Array<DoiDataAttributesCreatorsInnerNameIdentifiersInner>}
     * @memberof DoiDataAttributesContributorsInner
     */
    'nameIdentifiers'?: Array<DoiDataAttributesCreatorsInnerNameIdentifiersInner>;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesContributorsInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesContributorsInner
     */
    'givenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesContributorsInner
     */
    'familyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesContributorsInner
     */
    'affiliation'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesContributorsInner
     */
    'contributorType'?: string;
}
/**
 * 
 * @export
 * @interface DoiDataAttributesCreatorsInner
 */
export interface DoiDataAttributesCreatorsInner {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesCreatorsInner
     */
    'nameType'?: string;
    /**
     * 
     * @type {Array<DoiDataAttributesCreatorsInnerNameIdentifiersInner>}
     * @memberof DoiDataAttributesCreatorsInner
     */
    'nameIdentifiers'?: Array<DoiDataAttributesCreatorsInnerNameIdentifiersInner>;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesCreatorsInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesCreatorsInner
     */
    'givenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesCreatorsInner
     */
    'familyName'?: string;
    /**
     * 
     * @type {Array<DoiDataAttributesCreatorsInnerAffiliationInner>}
     * @memberof DoiDataAttributesCreatorsInner
     */
    'affiliation'?: Array<DoiDataAttributesCreatorsInnerAffiliationInner>;
}
/**
 * 
 * @export
 * @interface DoiDataAttributesCreatorsInnerAffiliationInner
 */
export interface DoiDataAttributesCreatorsInnerAffiliationInner {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesCreatorsInnerAffiliationInner
     */
    'affiliationIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesCreatorsInnerAffiliationInner
     */
    'affiliationIdentifierScheme'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesCreatorsInnerAffiliationInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesCreatorsInnerAffiliationInner
     */
    'schemeUri'?: string;
}
/**
 * 
 * @export
 * @interface DoiDataAttributesCreatorsInnerNameIdentifiersInner
 */
export interface DoiDataAttributesCreatorsInnerNameIdentifiersInner {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesCreatorsInnerNameIdentifiersInner
     */
    'nameIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesCreatorsInnerNameIdentifiersInner
     */
    'nameIdentifierScheme'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesCreatorsInnerNameIdentifiersInner
     */
    'schemeUri'?: string;
}
/**
 * 
 * @export
 * @interface DoiDataAttributesDatesInner
 */
export interface DoiDataAttributesDatesInner {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesDatesInner
     */
    'date'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesDatesInner
     */
    'dateType'?: string;
}
/**
 * 
 * @export
 * @interface DoiDataAttributesDescriptionsInner
 */
export interface DoiDataAttributesDescriptionsInner {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesDescriptionsInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesDescriptionsInner
     */
    'descriptionType'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesDescriptionsInner
     */
    'lang'?: string;
}
/**
 * 
 * @export
 * @interface DoiDataAttributesFundingReferencesInner
 */
export interface DoiDataAttributesFundingReferencesInner {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesFundingReferencesInner
     */
    'funderName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesFundingReferencesInner
     */
    'funderIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesFundingReferencesInner
     */
    'funderIdentifierType'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesFundingReferencesInner
     */
    'awardNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesFundingReferencesInner
     */
    'awardUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesFundingReferencesInner
     */
    'awardTitle'?: string;
}
/**
 * 
 * @export
 * @interface DoiDataAttributesGeoLocationsInner
 */
export interface DoiDataAttributesGeoLocationsInner {
    /**
     * 
     * @type {object}
     * @memberof DoiDataAttributesGeoLocationsInner
     */
    'geoLocationPoint'?: object;
    /**
     * 
     * @type {object}
     * @memberof DoiDataAttributesGeoLocationsInner
     */
    'geoLocationBox'?: object;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesGeoLocationsInner
     */
    'geoLocationPlace'?: string;
}
/**
 * 
 * @export
 * @interface DoiDataAttributesIdentifiersInner
 */
export interface DoiDataAttributesIdentifiersInner {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesIdentifiersInner
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesIdentifiersInner
     */
    'identifierType'?: string;
}
/**
 * Data describing the landing page, used by link checking.
 * @export
 * @interface DoiDataAttributesLandingPage
 */
export interface DoiDataAttributesLandingPage {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesLandingPage
     */
    'checked'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesLandingPage
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesLandingPage
     */
    'contentType'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesLandingPage
     */
    'error'?: string;
    /**
     * 
     * @type {number}
     * @memberof DoiDataAttributesLandingPage
     */
    'redirectCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DoiDataAttributesLandingPage
     */
    'redirectUrls'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DoiDataAttributesLandingPage
     */
    'downloadLatency'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DoiDataAttributesLandingPage
     */
    'hasSchemaOrg'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesLandingPage
     */
    'schemaOrgid'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesLandingPage
     */
    'dcIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesLandingPage
     */
    'citationDoi'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DoiDataAttributesLandingPage
     */
    'bodyhasPid'?: boolean;
}
/**
 * 
 * @export
 * @interface DoiDataAttributesRelatedIdentifiersInner
 */
export interface DoiDataAttributesRelatedIdentifiersInner {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesRelatedIdentifiersInner
     */
    'relatedIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesRelatedIdentifiersInner
     */
    'relatedIdentifierType'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesRelatedIdentifiersInner
     */
    'relationType'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesRelatedIdentifiersInner
     */
    'resourceTypeGeneral'?: string;
}
/**
 * 
 * @export
 * @interface DoiDataAttributesRightsListInner
 */
export interface DoiDataAttributesRightsListInner {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesRightsListInner
     */
    'rights'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesRightsListInner
     */
    'rightsUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesRightsListInner
     */
    'lang'?: string;
}
/**
 * 
 * @export
 * @interface DoiDataAttributesSubjectsInner
 */
export interface DoiDataAttributesSubjectsInner {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesSubjectsInner
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesSubjectsInner
     */
    'subjectScheme'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesSubjectsInner
     */
    'schemeUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesSubjectsInner
     */
    'valueUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesSubjectsInner
     */
    'lang'?: string;
}
/**
 * 
 * @export
 * @interface DoiDataAttributesTitlesInner
 */
export interface DoiDataAttributesTitlesInner {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesTitlesInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesTitlesInner
     */
    'titleType'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesTitlesInner
     */
    'lang'?: string;
}
/**
 * 
 * @export
 * @interface DoiDataAttributesTypes
 */
export interface DoiDataAttributesTypes {
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesTypes
     */
    'resourceTypeGeneral'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesTypes
     */
    'resourceType'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesTypes
     */
    'schemaOrg'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesTypes
     */
    'bibtex'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesTypes
     */
    'citeproc'?: string;
    /**
     * 
     * @type {string}
     * @memberof DoiDataAttributesTypes
     */
    'ris'?: string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {EventData}
     * @memberof Event
     */
    'data'?: EventData;
}
/**
 * 
 * @export
 * @interface EventData
 */
export interface EventData {
    /**
     * 
     * @type {string}
     * @memberof EventData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventData
     */
    'type'?: string;
    /**
     * 
     * @type {EventDataAttributes}
     * @memberof EventData
     */
    'attributes'?: EventDataAttributes;
}
/**
 * 
 * @export
 * @interface EventDataAttributes
 */
export interface EventDataAttributes {
    /**
     * 
     * @type {string}
     * @memberof EventDataAttributes
     */
    'subjId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDataAttributes
     */
    'objId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDataAttributes
     */
    'messageAction'?: EventDataAttributesMessageActionEnum;
    /**
     * 
     * @type {string}
     * @memberof EventDataAttributes
     */
    'relationTypeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDataAttributes
     */
    'sourceToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDataAttributes
     */
    'sourceId'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventDataAttributes
     */
    'total'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventDataAttributes
     */
    'license'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDataAttributes
     */
    'occuredAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventDataAttributes
     */
    'timestamp'?: string;
    /**
     * 
     * @type {object}
     * @memberof EventDataAttributes
     */
    'subj'?: object;
    /**
     * 
     * @type {object}
     * @memberof EventDataAttributes
     */
    'obj'?: object;
}

export const EventDataAttributesMessageActionEnum = {
    Create: 'create',
    Delete: 'delete'
} as const;

export type EventDataAttributesMessageActionEnum = typeof EventDataAttributesMessageActionEnum[keyof typeof EventDataAttributesMessageActionEnum];

/**
 * 
 * @export
 * @interface Prefix
 */
export interface Prefix {
    /**
     * 
     * @type {PrefixData}
     * @memberof Prefix
     */
    'data'?: PrefixData;
}
/**
 * 
 * @export
 * @interface PrefixData
 */
export interface PrefixData {
    /**
     * 
     * @type {string}
     * @memberof PrefixData
     */
    'prefix'?: string;
}
/**
 * 
 * @export
 * @interface Provider
 */
export interface Provider {
    /**
     * 
     * @type {ProviderData}
     * @memberof Provider
     */
    'data'?: ProviderData;
}
/**
 * 
 * @export
 * @interface ProviderData
 */
export interface ProviderData {
    /**
     * 
     * @type {string}
     * @memberof ProviderData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderData
     */
    'symbol'?: string;
}
/**
 * 
 * @export
 * @interface ProviderPrefix
 */
export interface ProviderPrefix {
    /**
     * 
     * @type {ProviderPrefixData}
     * @memberof ProviderPrefix
     */
    'data'?: ProviderPrefixData;
}
/**
 * 
 * @export
 * @interface ProviderPrefixData
 */
export interface ProviderPrefixData {
    /**
     * 
     * @type {string}
     * @memberof ProviderPrefixData
     */
    'id'?: string;
    /**
     * 
     * @type {ClientPrefixDataAttributes}
     * @memberof ProviderPrefixData
     */
    'attributes'?: ClientPrefixDataAttributes;
}
/**
 * Describes the formatting needs for the COUNTER Dataset Report. Response may include the Report_Header (optional), Report_Datasets (usage stats).
 * @export
 * @interface Report
 */
export interface Report {
    /**
     * 
     * @type {ReportData}
     * @memberof Report
     */
    'data'?: ReportData;
}
/**
 * 
 * @export
 * @interface ReportData
 */
export interface ReportData {
    /**
     * 
     * @type {string}
     * @memberof ReportData
     */
    'id'?: string;
    /**
     * The long name of the report.
     * @type {string}
     * @memberof ReportData
     */
    'report-name'?: string;
    /**
     * The report ID or code or shortname. Typically this will be the same code provided in the Report parameter of the request.
     * @type {string}
     * @memberof ReportData
     */
    'report-id'?: string;
    /**
     * The release or version of the report.
     * @type {string}
     * @memberof ReportData
     */
    'release'?: string;
    /**
     * Time the report was prepared. Format as defined by date-time - RFC3339
     * @type {string}
     * @memberof ReportData
     */
    'created'?: string;
    /**
     * Name of the organization producing the report.
     * @type {string}
     * @memberof ReportData
     */
    'created-by'?: string;
    /**
     * Zero or more report filters used for this report. Typically reflect filters provided on the Request. Filters limit the data to be reported on.
     * @type {string}
     * @memberof ReportData
     */
    'report-filters'?: string;
    /**
     * Zero or more additional attributes applied to the report. Attributes inform the level of detail in the report.
     * @type {string}
     * @memberof ReportData
     */
    'report-attributes'?: string;
    /**
     * Time the report was prepared.
     * @type {string}
     * @memberof ReportData
     */
    'reporting-period'?: string;
    /**
     * Defines the output for the Report_Datasets being returned in a Dataset Report. Collection of datasets from the report.
     * @type {string}
     * @memberof ReportData
     */
    'report-datasets'?: string;
}

/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
export const ActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a JSON API result of activities.
         * @param {string} [id] Find activity by an id
         * @param {Array<string>} [ids] Find activities by array of activity ids
         * @param {string} [query] Search the index by keyword or query string syntax.
         * @param {number} [pageNumber] Pagination - page number
         * @param {number} [pageSize] Pagination - page size
         * @param {number} [pageCursor] Pagination - page cursor (used instead of page[number])
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitiesGet: async (id?: string, ids?: Array<string>, query?: string, pageNumber?: number, pageSize?: number, pageCursor?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['page[cursor]'] = pageCursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a JSON API result of a specific activity
         * @param {string} id Activity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitiesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('activitiesIdGet', 'id', id)
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns activity for a specific DOI
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doisIdActivitiesGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('doisIdActivitiesGet', 'id', id)
            const localVarPath = `/dois/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a JSON API result of activities.
         * @param {string} [id] Find activity by an id
         * @param {Array<string>} [ids] Find activities by array of activity ids
         * @param {string} [query] Search the index by keyword or query string syntax.
         * @param {number} [pageNumber] Pagination - page number
         * @param {number} [pageSize] Pagination - page size
         * @param {number} [pageCursor] Pagination - page cursor (used instead of page[number])
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activitiesGet(id?: string, ids?: Array<string>, query?: string, pageNumber?: number, pageSize?: number, pageCursor?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activitiesGet(id, ids, query, pageNumber, pageSize, pageCursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a JSON API result of a specific activity
         * @param {string} id Activity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activitiesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activitiesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns activity for a specific DOI
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doisIdActivitiesGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doisIdActivitiesGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivitiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a JSON API result of activities.
         * @param {string} [id] Find activity by an id
         * @param {Array<string>} [ids] Find activities by array of activity ids
         * @param {string} [query] Search the index by keyword or query string syntax.
         * @param {number} [pageNumber] Pagination - page number
         * @param {number} [pageSize] Pagination - page size
         * @param {number} [pageCursor] Pagination - page cursor (used instead of page[number])
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitiesGet(id?: string, ids?: Array<string>, query?: string, pageNumber?: number, pageSize?: number, pageCursor?: number, options?: any): AxiosPromise<Activity> {
            return localVarFp.activitiesGet(id, ids, query, pageNumber, pageSize, pageCursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a JSON API result of a specific activity
         * @param {string} id Activity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitiesIdGet(id: string, options?: any): AxiosPromise<Activity> {
            return localVarFp.activitiesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns activity for a specific DOI
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doisIdActivitiesGet(id: string, options?: any): AxiosPromise<Activity> {
            return localVarFp.doisIdActivitiesGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * 
     * @summary Get a JSON API result of activities.
     * @param {string} [id] Find activity by an id
     * @param {Array<string>} [ids] Find activities by array of activity ids
     * @param {string} [query] Search the index by keyword or query string syntax.
     * @param {number} [pageNumber] Pagination - page number
     * @param {number} [pageSize] Pagination - page size
     * @param {number} [pageCursor] Pagination - page cursor (used instead of page[number])
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public activitiesGet(id?: string, ids?: Array<string>, query?: string, pageNumber?: number, pageSize?: number, pageCursor?: number, options?: AxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).activitiesGet(id, ids, query, pageNumber, pageSize, pageCursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a JSON API result of a specific activity
     * @param {string} id Activity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public activitiesIdGet(id: string, options?: AxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).activitiesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns activity for a specific DOI
     * @param {string} id DOI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public doisIdActivitiesGet(id: string, options?: AxiosRequestConfig) {
        return ActivitiesApiFp(this.configuration).doisIdActivitiesGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientPrefixesApi - axios parameter creator
 * @export
 */
export const ClientPrefixesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a list of client-prefixes.
         * @param {string} [query] 
         * @param {number} [year] 
         * @param {string} [clientId] 
         * @param {string} [prefixId] 
         * @param {number} [page] 
         * @param {'name' | '-name' | 'created' | '-created'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientPrefixesGet: async (query?: string, year?: number, clientId?: string, prefixId?: string, page?: number, sort?: 'name' | '-name' | 'created' | '-created', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/client-prefixes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client-id'] = clientId;
            }

            if (prefixId !== undefined) {
                localVarQueryParameter['prefix-id'] = prefixId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientPrefixesApi - functional programming interface
 * @export
 */
export const ClientPrefixesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientPrefixesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a list of client-prefixes.
         * @param {string} [query] 
         * @param {number} [year] 
         * @param {string} [clientId] 
         * @param {string} [prefixId] 
         * @param {number} [page] 
         * @param {'name' | '-name' | 'created' | '-created'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientPrefixesGet(query?: string, year?: number, clientId?: string, prefixId?: string, page?: number, sort?: 'name' | '-name' | 'created' | '-created', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientPrefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientPrefixesGet(query, year, clientId, prefixId, page, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientPrefixesApi - factory interface
 * @export
 */
export const ClientPrefixesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientPrefixesApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a list of client-prefixes.
         * @param {string} [query] 
         * @param {number} [year] 
         * @param {string} [clientId] 
         * @param {string} [prefixId] 
         * @param {number} [page] 
         * @param {'name' | '-name' | 'created' | '-created'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientPrefixesGet(query?: string, year?: number, clientId?: string, prefixId?: string, page?: number, sort?: 'name' | '-name' | 'created' | '-created', options?: any): AxiosPromise<ClientPrefix> {
            return localVarFp.clientPrefixesGet(query, year, clientId, prefixId, page, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientPrefixesApi - object-oriented interface
 * @export
 * @class ClientPrefixesApi
 * @extends {BaseAPI}
 */
export class ClientPrefixesApi extends BaseAPI {
    /**
     * 
     * @summary Returns a list of client-prefixes.
     * @param {string} [query] 
     * @param {number} [year] 
     * @param {string} [clientId] 
     * @param {string} [prefixId] 
     * @param {number} [page] 
     * @param {'name' | '-name' | 'created' | '-created'} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientPrefixesApi
     */
    public clientPrefixesGet(query?: string, year?: number, clientId?: string, prefixId?: string, page?: number, sort?: 'name' | '-name' | 'created' | '-created', options?: AxiosRequestConfig) {
        return ClientPrefixesApiFp(this.configuration).clientPrefixesGet(query, year, clientId, prefixId, page, sort, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientsApi - axios parameter creator
 * @export
 */
export const ClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a list of clients.
         * @param {string} [query] 
         * @param {number} [year] 
         * @param {string} [providerId] 
         * @param {'ckan' | 'dataverse' | 'dspace' | 'eprints' | 'escidoc' | 'fedora' | 'hal' | 'invenio' | 'islandora' | 'mysql' | 'nesstar' | 'opus'} [software] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {'provider' | 'repository'} [include] 
         * @param {'relevance' | 'name' | '-name' | 'created' | '-created'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsGet: async (query?: string, year?: number, providerId?: string, software?: 'ckan' | 'dataverse' | 'dspace' | 'eprints' | 'escidoc' | 'fedora' | 'hal' | 'invenio' | 'islandora' | 'mysql' | 'nesstar' | 'opus', pageNumber?: number, pageSize?: number, include?: 'provider' | 'repository', sort?: 'relevance' | 'name' | '-name' | 'created' | '-created', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['provider-id'] = providerId;
            }

            if (software !== undefined) {
                localVarQueryParameter['software'] = software;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a client.
         * @param {string} id Client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientsIdDelete', 'id', id)
            const localVarPath = `/clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a client.
         * @param {string} id Client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientsIdGet', 'id', id)
            const localVarPath = `/clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a client.
         * @param {string} id Client ID
         * @param {Client} client 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsIdPut: async (id: string, client: Client, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientsIdPut', 'id', id)
            // verify required parameter 'client' is not null or undefined
            assertParamExists('clientsIdPut', 'client', client)
            const localVarPath = `/clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(client, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new client.
         * @param {Client} client 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsPost: async (client: Client, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'client' is not null or undefined
            assertParamExists('clientsPost', 'client', client)
            const localVarPath = `/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(client, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns Clients DOI production statistics.
         * @param {string} [providerId] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsTotalsGet: async (providerId?: string, state?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/clients/totals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (providerId !== undefined) {
                localVarQueryParameter['provider-id'] = providerId;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientsApi - functional programming interface
 * @export
 */
export const ClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a list of clients.
         * @param {string} [query] 
         * @param {number} [year] 
         * @param {string} [providerId] 
         * @param {'ckan' | 'dataverse' | 'dspace' | 'eprints' | 'escidoc' | 'fedora' | 'hal' | 'invenio' | 'islandora' | 'mysql' | 'nesstar' | 'opus'} [software] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {'provider' | 'repository'} [include] 
         * @param {'relevance' | 'name' | '-name' | 'created' | '-created'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsGet(query?: string, year?: number, providerId?: string, software?: 'ckan' | 'dataverse' | 'dspace' | 'eprints' | 'escidoc' | 'fedora' | 'hal' | 'invenio' | 'islandora' | 'mysql' | 'nesstar' | 'opus', pageNumber?: number, pageSize?: number, include?: 'provider' | 'repository', sort?: 'relevance' | 'name' | '-name' | 'created' | '-created', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientsGet(query, year, providerId, software, pageNumber, pageSize, include, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a client.
         * @param {string} id Client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a client.
         * @param {string} id Client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a client.
         * @param {string} id Client ID
         * @param {Client} client 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsIdPut(id: string, client: Client, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientsIdPut(id, client, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new client.
         * @param {Client} client 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsPost(client: Client, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientsPost(client, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns Clients DOI production statistics.
         * @param {string} [providerId] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientsTotalsGet(providerId?: string, state?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientsTotalsGet(providerId, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientsApi - factory interface
 * @export
 */
export const ClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientsApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a list of clients.
         * @param {string} [query] 
         * @param {number} [year] 
         * @param {string} [providerId] 
         * @param {'ckan' | 'dataverse' | 'dspace' | 'eprints' | 'escidoc' | 'fedora' | 'hal' | 'invenio' | 'islandora' | 'mysql' | 'nesstar' | 'opus'} [software] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {'provider' | 'repository'} [include] 
         * @param {'relevance' | 'name' | '-name' | 'created' | '-created'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsGet(query?: string, year?: number, providerId?: string, software?: 'ckan' | 'dataverse' | 'dspace' | 'eprints' | 'escidoc' | 'fedora' | 'hal' | 'invenio' | 'islandora' | 'mysql' | 'nesstar' | 'opus', pageNumber?: number, pageSize?: number, include?: 'provider' | 'repository', sort?: 'relevance' | 'name' | '-name' | 'created' | '-created', options?: any): AxiosPromise<Client> {
            return localVarFp.clientsGet(query, year, providerId, software, pageNumber, pageSize, include, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a client.
         * @param {string} id Client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.clientsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a client.
         * @param {string} id Client ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsIdGet(id: string, options?: any): AxiosPromise<Client> {
            return localVarFp.clientsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a client.
         * @param {string} id Client ID
         * @param {Client} client 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsIdPut(id: string, client: Client, options?: any): AxiosPromise<void> {
            return localVarFp.clientsIdPut(id, client, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new client.
         * @param {Client} client 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsPost(client: Client, options?: any): AxiosPromise<void> {
            return localVarFp.clientsPost(client, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns Clients DOI production statistics.
         * @param {string} [providerId] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientsTotalsGet(providerId?: string, state?: string, options?: any): AxiosPromise<void> {
            return localVarFp.clientsTotalsGet(providerId, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientsApi - object-oriented interface
 * @export
 * @class ClientsApi
 * @extends {BaseAPI}
 */
export class ClientsApi extends BaseAPI {
    /**
     * 
     * @summary Returns a list of clients.
     * @param {string} [query] 
     * @param {number} [year] 
     * @param {string} [providerId] 
     * @param {'ckan' | 'dataverse' | 'dspace' | 'eprints' | 'escidoc' | 'fedora' | 'hal' | 'invenio' | 'islandora' | 'mysql' | 'nesstar' | 'opus'} [software] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {'provider' | 'repository'} [include] 
     * @param {'relevance' | 'name' | '-name' | 'created' | '-created'} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public clientsGet(query?: string, year?: number, providerId?: string, software?: 'ckan' | 'dataverse' | 'dspace' | 'eprints' | 'escidoc' | 'fedora' | 'hal' | 'invenio' | 'islandora' | 'mysql' | 'nesstar' | 'opus', pageNumber?: number, pageSize?: number, include?: 'provider' | 'repository', sort?: 'relevance' | 'name' | '-name' | 'created' | '-created', options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).clientsGet(query, year, providerId, software, pageNumber, pageSize, include, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a client.
     * @param {string} id Client ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public clientsIdDelete(id: string, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).clientsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a client.
     * @param {string} id Client ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public clientsIdGet(id: string, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).clientsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a client.
     * @param {string} id Client ID
     * @param {Client} client 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public clientsIdPut(id: string, client: Client, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).clientsIdPut(id, client, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new client.
     * @param {Client} client 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public clientsPost(client: Client, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).clientsPost(client, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns Clients DOI production statistics.
     * @param {string} [providerId] 
     * @param {string} [state] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientsApi
     */
    public clientsTotalsGet(providerId?: string, state?: string, options?: AxiosRequestConfig) {
        return ClientsApiFp(this.configuration).clientsTotalsGet(providerId, state, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DoisApi - axios parameter creator
 * @export
 */
export const DoisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return a list of dois.
         * @param {string} [query] 
         * @param {number} [created] 
         * @param {number} [registered] 
         * @param {string} [providerId] 
         * @param {string} [clientId] 
         * @param {string} [personId] 
         * @param {string} [resourceTypeId] 
         * @param {string} [subject] 
         * @param {string} [schemaVersion] 
         * @param {boolean} [random] 
         * @param {number} [sampleSize] 
         * @param {'client' | 'provider' | 'resource-type'} [sampleGroup] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {number} [pageCursor] 
         * @param {'client' | 'media'} [include] 
         * @param {'relevance' | 'name' | '-name' | 'created' | '-created' | 'updated' | '-updated'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doisGet: async (query?: string, created?: number, registered?: number, providerId?: string, clientId?: string, personId?: string, resourceTypeId?: string, subject?: string, schemaVersion?: string, random?: boolean, sampleSize?: number, sampleGroup?: 'client' | 'provider' | 'resource-type', pageNumber?: number, pageSize?: number, pageCursor?: number, include?: 'client' | 'media', sort?: 'relevance' | 'name' | '-name' | 'created' | '-created' | 'updated' | '-updated', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dois`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (registered !== undefined) {
                localVarQueryParameter['registered'] = registered;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['provider-id'] = providerId;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client-id'] = clientId;
            }

            if (personId !== undefined) {
                localVarQueryParameter['person-id'] = personId;
            }

            if (resourceTypeId !== undefined) {
                localVarQueryParameter['resource-type-id'] = resourceTypeId;
            }

            if (subject !== undefined) {
                localVarQueryParameter['subject'] = subject;
            }

            if (schemaVersion !== undefined) {
                localVarQueryParameter['schema-version'] = schemaVersion;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (sampleSize !== undefined) {
                localVarQueryParameter['sample-size'] = sampleSize;
            }

            if (sampleGroup !== undefined) {
                localVarQueryParameter['sample-group'] = sampleGroup;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['page[cursor]'] = pageCursor;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns activity for a specific DOI
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doisIdActivitiesGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('doisIdActivitiesGet', 'id', id)
            const localVarPath = `/dois/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a doi.
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doisIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('doisIdDelete', 'id', id)
            const localVarPath = `/dois/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a doi.
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doisIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('doisIdGet', 'id', id)
            const localVarPath = `/dois/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a doi.
         * @param {string} id DOI
         * @param {Doi} doi 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doisIdPut: async (id: string, doi: Doi, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('doisIdPut', 'id', id)
            // verify required parameter 'doi' is not null or undefined
            assertParamExists('doisIdPut', 'doi', doi)
            const localVarPath = `/dois/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(doi, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new doi.
         * @param {Doi} doi 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doisPost: async (doi: Doi, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'doi' is not null or undefined
            assertParamExists('doisPost', 'doi', doi)
            const localVarPath = `/dois`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(doi, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DoisApi - functional programming interface
 * @export
 */
export const DoisApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DoisApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Return a list of dois.
         * @param {string} [query] 
         * @param {number} [created] 
         * @param {number} [registered] 
         * @param {string} [providerId] 
         * @param {string} [clientId] 
         * @param {string} [personId] 
         * @param {string} [resourceTypeId] 
         * @param {string} [subject] 
         * @param {string} [schemaVersion] 
         * @param {boolean} [random] 
         * @param {number} [sampleSize] 
         * @param {'client' | 'provider' | 'resource-type'} [sampleGroup] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {number} [pageCursor] 
         * @param {'client' | 'media'} [include] 
         * @param {'relevance' | 'name' | '-name' | 'created' | '-created' | 'updated' | '-updated'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doisGet(query?: string, created?: number, registered?: number, providerId?: string, clientId?: string, personId?: string, resourceTypeId?: string, subject?: string, schemaVersion?: string, random?: boolean, sampleSize?: number, sampleGroup?: 'client' | 'provider' | 'resource-type', pageNumber?: number, pageSize?: number, pageCursor?: number, include?: 'client' | 'media', sort?: 'relevance' | 'name' | '-name' | 'created' | '-created' | 'updated' | '-updated', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Doi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doisGet(query, created, registered, providerId, clientId, personId, resourceTypeId, subject, schemaVersion, random, sampleSize, sampleGroup, pageNumber, pageSize, pageCursor, include, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns activity for a specific DOI
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doisIdActivitiesGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doisIdActivitiesGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a doi.
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doisIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doisIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a doi.
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doisIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Doi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doisIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a doi.
         * @param {string} id DOI
         * @param {Doi} doi 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doisIdPut(id: string, doi: Doi, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doisIdPut(id, doi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new doi.
         * @param {Doi} doi 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doisPost(doi: Doi, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doisPost(doi, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DoisApi - factory interface
 * @export
 */
export const DoisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DoisApiFp(configuration)
    return {
        /**
         * 
         * @summary Return a list of dois.
         * @param {string} [query] 
         * @param {number} [created] 
         * @param {number} [registered] 
         * @param {string} [providerId] 
         * @param {string} [clientId] 
         * @param {string} [personId] 
         * @param {string} [resourceTypeId] 
         * @param {string} [subject] 
         * @param {string} [schemaVersion] 
         * @param {boolean} [random] 
         * @param {number} [sampleSize] 
         * @param {'client' | 'provider' | 'resource-type'} [sampleGroup] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {number} [pageCursor] 
         * @param {'client' | 'media'} [include] 
         * @param {'relevance' | 'name' | '-name' | 'created' | '-created' | 'updated' | '-updated'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doisGet(query?: string, created?: number, registered?: number, providerId?: string, clientId?: string, personId?: string, resourceTypeId?: string, subject?: string, schemaVersion?: string, random?: boolean, sampleSize?: number, sampleGroup?: 'client' | 'provider' | 'resource-type', pageNumber?: number, pageSize?: number, pageCursor?: number, include?: 'client' | 'media', sort?: 'relevance' | 'name' | '-name' | 'created' | '-created' | 'updated' | '-updated', options?: any): AxiosPromise<Doi> {
            return localVarFp.doisGet(query, created, registered, providerId, clientId, personId, resourceTypeId, subject, schemaVersion, random, sampleSize, sampleGroup, pageNumber, pageSize, pageCursor, include, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns activity for a specific DOI
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doisIdActivitiesGet(id: string, options?: any): AxiosPromise<Activity> {
            return localVarFp.doisIdActivitiesGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a doi.
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doisIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.doisIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a doi.
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doisIdGet(id: string, options?: any): AxiosPromise<Doi> {
            return localVarFp.doisIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a doi.
         * @param {string} id DOI
         * @param {Doi} doi 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doisIdPut(id: string, doi: Doi, options?: any): AxiosPromise<void> {
            return localVarFp.doisIdPut(id, doi, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new doi.
         * @param {Doi} doi 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doisPost(doi: Doi, options?: any): AxiosPromise<void> {
            return localVarFp.doisPost(doi, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DoisApi - object-oriented interface
 * @export
 * @class DoisApi
 * @extends {BaseAPI}
 */
export class DoisApi extends BaseAPI {
    /**
     * 
     * @summary Return a list of dois.
     * @param {string} [query] 
     * @param {number} [created] 
     * @param {number} [registered] 
     * @param {string} [providerId] 
     * @param {string} [clientId] 
     * @param {string} [personId] 
     * @param {string} [resourceTypeId] 
     * @param {string} [subject] 
     * @param {string} [schemaVersion] 
     * @param {boolean} [random] 
     * @param {number} [sampleSize] 
     * @param {'client' | 'provider' | 'resource-type'} [sampleGroup] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {number} [pageCursor] 
     * @param {'client' | 'media'} [include] 
     * @param {'relevance' | 'name' | '-name' | 'created' | '-created' | 'updated' | '-updated'} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoisApi
     */
    public doisGet(query?: string, created?: number, registered?: number, providerId?: string, clientId?: string, personId?: string, resourceTypeId?: string, subject?: string, schemaVersion?: string, random?: boolean, sampleSize?: number, sampleGroup?: 'client' | 'provider' | 'resource-type', pageNumber?: number, pageSize?: number, pageCursor?: number, include?: 'client' | 'media', sort?: 'relevance' | 'name' | '-name' | 'created' | '-created' | 'updated' | '-updated', options?: AxiosRequestConfig) {
        return DoisApiFp(this.configuration).doisGet(query, created, registered, providerId, clientId, personId, resourceTypeId, subject, schemaVersion, random, sampleSize, sampleGroup, pageNumber, pageSize, pageCursor, include, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns activity for a specific DOI
     * @param {string} id DOI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoisApi
     */
    public doisIdActivitiesGet(id: string, options?: AxiosRequestConfig) {
        return DoisApiFp(this.configuration).doisIdActivitiesGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a doi.
     * @param {string} id DOI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoisApi
     */
    public doisIdDelete(id: string, options?: AxiosRequestConfig) {
        return DoisApiFp(this.configuration).doisIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a doi.
     * @param {string} id DOI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoisApi
     */
    public doisIdGet(id: string, options?: AxiosRequestConfig) {
        return DoisApiFp(this.configuration).doisIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a doi.
     * @param {string} id DOI
     * @param {Doi} doi 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoisApi
     */
    public doisIdPut(id: string, doi: Doi, options?: AxiosRequestConfig) {
        return DoisApiFp(this.configuration).doisIdPut(id, doi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new doi.
     * @param {Doi} doi 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DoisApi
     */
    public doisPost(doi: Doi, options?: AxiosRequestConfig) {
        return DoisApiFp(this.configuration).doisPost(doi, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a list of events.
         * @param {string} [query] 
         * @param {string} [subjId] 
         * @param {string} [objId] 
         * @param {string} [doi] 
         * @param {string} [orcid] 
         * @param {string} [prefix] 
         * @param {string} [subtype] 
         * @param {string} [citationType] 
         * @param {string} [sourceId] 
         * @param {string} [registrantId] 
         * @param {string} [relationTypeId] 
         * @param {string} [issn] 
         * @param {string} [publicationYear] 
         * @param {string} [yearMonth] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {number} [pageCursor] 
         * @param {'subj' | 'obj'} [include] 
         * @param {'relevance' | 'name' | '-name' | 'created' | '-created'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGet: async (query?: string, subjId?: string, objId?: string, doi?: string, orcid?: string, prefix?: string, subtype?: string, citationType?: string, sourceId?: string, registrantId?: string, relationTypeId?: string, issn?: string, publicationYear?: string, yearMonth?: string, pageNumber?: number, pageSize?: number, pageCursor?: number, include?: 'subj' | 'obj', sort?: 'relevance' | 'name' | '-name' | 'created' | '-created', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (subjId !== undefined) {
                localVarQueryParameter['subj-id'] = subjId;
            }

            if (objId !== undefined) {
                localVarQueryParameter['obj-id'] = objId;
            }

            if (doi !== undefined) {
                localVarQueryParameter['doi'] = doi;
            }

            if (orcid !== undefined) {
                localVarQueryParameter['orcid'] = orcid;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (subtype !== undefined) {
                localVarQueryParameter['subtype'] = subtype;
            }

            if (citationType !== undefined) {
                localVarQueryParameter['citation-type'] = citationType;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['source-id'] = sourceId;
            }

            if (registrantId !== undefined) {
                localVarQueryParameter['registrant-id'] = registrantId;
            }

            if (relationTypeId !== undefined) {
                localVarQueryParameter['relation-type-id'] = relationTypeId;
            }

            if (issn !== undefined) {
                localVarQueryParameter['issn'] = issn;
            }

            if (publicationYear !== undefined) {
                localVarQueryParameter['publication-year'] = publicationYear;
            }

            if (yearMonth !== undefined) {
                localVarQueryParameter['year-month'] = yearMonth;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (pageCursor !== undefined) {
                localVarQueryParameter['page[cursor]'] = pageCursor;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an event.
         * @param {string} id Event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsIdDelete', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns an event.
         * @param {string} id Event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsIdGet', 'id', id)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an event.
         * @param {string} id Event
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdPut: async (id: string, event: Event, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventsIdPut', 'id', id)
            // verify required parameter 'event' is not null or undefined
            assertParamExists('eventsIdPut', 'event', event)
            const localVarPath = `/events/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(event, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new event.
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPost: async (event: Event, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'event' is not null or undefined
            assertParamExists('eventsPost', 'event', event)
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(event, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a list of events.
         * @param {string} [query] 
         * @param {string} [subjId] 
         * @param {string} [objId] 
         * @param {string} [doi] 
         * @param {string} [orcid] 
         * @param {string} [prefix] 
         * @param {string} [subtype] 
         * @param {string} [citationType] 
         * @param {string} [sourceId] 
         * @param {string} [registrantId] 
         * @param {string} [relationTypeId] 
         * @param {string} [issn] 
         * @param {string} [publicationYear] 
         * @param {string} [yearMonth] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {number} [pageCursor] 
         * @param {'subj' | 'obj'} [include] 
         * @param {'relevance' | 'name' | '-name' | 'created' | '-created'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsGet(query?: string, subjId?: string, objId?: string, doi?: string, orcid?: string, prefix?: string, subtype?: string, citationType?: string, sourceId?: string, registrantId?: string, relationTypeId?: string, issn?: string, publicationYear?: string, yearMonth?: string, pageNumber?: number, pageSize?: number, pageCursor?: number, include?: 'subj' | 'obj', sort?: 'relevance' | 'name' | '-name' | 'created' | '-created', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsGet(query, subjId, objId, doi, orcid, prefix, subtype, citationType, sourceId, registrantId, relationTypeId, issn, publicationYear, yearMonth, pageNumber, pageSize, pageCursor, include, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an event.
         * @param {string} id Event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns an event.
         * @param {string} id Event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an event.
         * @param {string} id Event
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsIdPut(id: string, event: Event, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsIdPut(id, event, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new event.
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsPost(event: Event, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsPost(event, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a list of events.
         * @param {string} [query] 
         * @param {string} [subjId] 
         * @param {string} [objId] 
         * @param {string} [doi] 
         * @param {string} [orcid] 
         * @param {string} [prefix] 
         * @param {string} [subtype] 
         * @param {string} [citationType] 
         * @param {string} [sourceId] 
         * @param {string} [registrantId] 
         * @param {string} [relationTypeId] 
         * @param {string} [issn] 
         * @param {string} [publicationYear] 
         * @param {string} [yearMonth] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {number} [pageCursor] 
         * @param {'subj' | 'obj'} [include] 
         * @param {'relevance' | 'name' | '-name' | 'created' | '-created'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsGet(query?: string, subjId?: string, objId?: string, doi?: string, orcid?: string, prefix?: string, subtype?: string, citationType?: string, sourceId?: string, registrantId?: string, relationTypeId?: string, issn?: string, publicationYear?: string, yearMonth?: string, pageNumber?: number, pageSize?: number, pageCursor?: number, include?: 'subj' | 'obj', sort?: 'relevance' | 'name' | '-name' | 'created' | '-created', options?: any): AxiosPromise<Event> {
            return localVarFp.eventsGet(query, subjId, objId, doi, orcid, prefix, subtype, citationType, sourceId, registrantId, relationTypeId, issn, publicationYear, yearMonth, pageNumber, pageSize, pageCursor, include, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an event.
         * @param {string} id Event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.eventsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns an event.
         * @param {string} id Event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdGet(id: string, options?: any): AxiosPromise<Event> {
            return localVarFp.eventsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an event.
         * @param {string} id Event
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsIdPut(id: string, event: Event, options?: any): AxiosPromise<void> {
            return localVarFp.eventsIdPut(id, event, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new event.
         * @param {Event} event 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPost(event: Event, options?: any): AxiosPromise<void> {
            return localVarFp.eventsPost(event, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * 
     * @summary Returns a list of events.
     * @param {string} [query] 
     * @param {string} [subjId] 
     * @param {string} [objId] 
     * @param {string} [doi] 
     * @param {string} [orcid] 
     * @param {string} [prefix] 
     * @param {string} [subtype] 
     * @param {string} [citationType] 
     * @param {string} [sourceId] 
     * @param {string} [registrantId] 
     * @param {string} [relationTypeId] 
     * @param {string} [issn] 
     * @param {string} [publicationYear] 
     * @param {string} [yearMonth] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {number} [pageCursor] 
     * @param {'subj' | 'obj'} [include] 
     * @param {'relevance' | 'name' | '-name' | 'created' | '-created'} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsGet(query?: string, subjId?: string, objId?: string, doi?: string, orcid?: string, prefix?: string, subtype?: string, citationType?: string, sourceId?: string, registrantId?: string, relationTypeId?: string, issn?: string, publicationYear?: string, yearMonth?: string, pageNumber?: number, pageSize?: number, pageCursor?: number, include?: 'subj' | 'obj', sort?: 'relevance' | 'name' | '-name' | 'created' | '-created', options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsGet(query, subjId, objId, doi, orcid, prefix, subtype, citationType, sourceId, registrantId, relationTypeId, issn, publicationYear, yearMonth, pageNumber, pageSize, pageCursor, include, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an event.
     * @param {string} id Event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsIdDelete(id: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns an event.
     * @param {string} id Event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsIdGet(id: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an event.
     * @param {string} id Event
     * @param {Event} event 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsIdPut(id: string, event: Event, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsIdPut(id, event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new event.
     * @param {Event} event 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsPost(event: Event, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsPost(event, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HeartbeatApi - axios parameter creator
 * @export
 */
export const HeartbeatApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary This resource returns the current status of the REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heartbeatGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/heartbeat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HeartbeatApi - functional programming interface
 * @export
 */
export const HeartbeatApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HeartbeatApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary This resource returns the current status of the REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heartbeatGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heartbeatGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HeartbeatApi - factory interface
 * @export
 */
export const HeartbeatApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HeartbeatApiFp(configuration)
    return {
        /**
         * 
         * @summary This resource returns the current status of the REST API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heartbeatGet(options?: any): AxiosPromise<string> {
            return localVarFp.heartbeatGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HeartbeatApi - object-oriented interface
 * @export
 * @class HeartbeatApi
 * @extends {BaseAPI}
 */
export class HeartbeatApi extends BaseAPI {
    /**
     * 
     * @summary This resource returns the current status of the REST API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartbeatApi
     */
    public heartbeatGet(options?: AxiosRequestConfig) {
        return HeartbeatApiFp(this.configuration).heartbeatGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PrefixesApi - axios parameter creator
 * @export
 */
export const PrefixesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a list of prefixes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prefixesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/prefixes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary A prefix.
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prefixesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('prefixesIdGet', 'id', id)
            const localVarPath = `/prefixes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns prefixes DOI production statistics.
         * @param {string} [clientId] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prefixesTotalsGet: async (clientId?: string, state?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/prefixes/totals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientId !== undefined) {
                localVarQueryParameter['client-id'] = clientId;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrefixesApi - functional programming interface
 * @export
 */
export const PrefixesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PrefixesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a list of prefixes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prefixesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prefixesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary A prefix.
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prefixesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prefixesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns prefixes DOI production statistics.
         * @param {string} [clientId] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prefixesTotalsGet(clientId?: string, state?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prefixesTotalsGet(clientId, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PrefixesApi - factory interface
 * @export
 */
export const PrefixesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PrefixesApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a list of prefixes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prefixesGet(options?: any): AxiosPromise<Prefix> {
            return localVarFp.prefixesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary A prefix.
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prefixesIdGet(id: string, options?: any): AxiosPromise<Prefix> {
            return localVarFp.prefixesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns prefixes DOI production statistics.
         * @param {string} [clientId] 
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prefixesTotalsGet(clientId?: string, state?: string, options?: any): AxiosPromise<void> {
            return localVarFp.prefixesTotalsGet(clientId, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PrefixesApi - object-oriented interface
 * @export
 * @class PrefixesApi
 * @extends {BaseAPI}
 */
export class PrefixesApi extends BaseAPI {
    /**
     * 
     * @summary Returns a list of prefixes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrefixesApi
     */
    public prefixesGet(options?: AxiosRequestConfig) {
        return PrefixesApiFp(this.configuration).prefixesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary A prefix.
     * @param {string} id DOI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrefixesApi
     */
    public prefixesIdGet(id: string, options?: AxiosRequestConfig) {
        return PrefixesApiFp(this.configuration).prefixesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns prefixes DOI production statistics.
     * @param {string} [clientId] 
     * @param {string} [state] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrefixesApi
     */
    public prefixesTotalsGet(clientId?: string, state?: string, options?: AxiosRequestConfig) {
        return PrefixesApiFp(this.configuration).prefixesTotalsGet(clientId, state, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProviderPrefixesApi - axios parameter creator
 * @export
 */
export const ProviderPrefixesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary A JSON array of provider-prefixes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerPrefixesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/provider-prefixes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderPrefixesApi - functional programming interface
 * @export
 */
export const ProviderPrefixesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderPrefixesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary A JSON array of provider-prefixes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerPrefixesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderPrefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerPrefixesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProviderPrefixesApi - factory interface
 * @export
 */
export const ProviderPrefixesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderPrefixesApiFp(configuration)
    return {
        /**
         * 
         * @summary A JSON array of provider-prefixes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerPrefixesGet(options?: any): AxiosPromise<ProviderPrefix> {
            return localVarFp.providerPrefixesGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProviderPrefixesApi - object-oriented interface
 * @export
 * @class ProviderPrefixesApi
 * @extends {BaseAPI}
 */
export class ProviderPrefixesApi extends BaseAPI {
    /**
     * 
     * @summary A JSON array of provider-prefixes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderPrefixesApi
     */
    public providerPrefixesGet(options?: AxiosRequestConfig) {
        return ProviderPrefixesApiFp(this.configuration).providerPrefixesGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProvidersApi - axios parameter creator
 * @export
 */
export const ProvidersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary A JSON array of providers.
         * @param {string} [query] 
         * @param {number} [year] 
         * @param {'amer' | 'apac' | 'emea'} [region] 
         * @param {'academicInstitution' | 'academicLibrary' | 'governmentAgency' | 'nationalInstitution' | 'nationalLibrary' | 'publisher' | 'professionalSociety' | 'researchInstitution' | 'serviceProvider' | 'vendor'} [organizationType] 
         * @param {'amer' | 'apac' | 'emea'} [focusArea] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {'relevance' | 'name' | '-name' | 'created' | '-created'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersGet: async (query?: string, year?: number, region?: 'amer' | 'apac' | 'emea', organizationType?: 'academicInstitution' | 'academicLibrary' | 'governmentAgency' | 'nationalInstitution' | 'nationalLibrary' | 'publisher' | 'professionalSociety' | 'researchInstitution' | 'serviceProvider' | 'vendor', focusArea?: 'amer' | 'apac' | 'emea', pageNumber?: number, pageSize?: number, sort?: 'relevance' | 'name' | '-name' | 'created' | '-created', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (organizationType !== undefined) {
                localVarQueryParameter['organization-type'] = organizationType;
            }

            if (focusArea !== undefined) {
                localVarQueryParameter['focus-area'] = focusArea;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a provider.
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('providersIdDelete', 'id', id)
            const localVarPath = `/providers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary A provider.
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('providersIdGet', 'id', id)
            const localVarPath = `/providers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a provider.
         * @param {string} id DOI
         * @param {Provider} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersIdPut: async (id: string, provider: Provider, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('providersIdPut', 'id', id)
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('providersIdPut', 'provider', provider)
            const localVarPath = `/providers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provider, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new provider.
         * @param {Provider} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersPost: async (provider: Provider, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('providersPost', 'provider', provider)
            const localVarPath = `/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provider, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns Providers DOI production statistics.
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersTotalsGet: async (state?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/providers/totals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvidersApi - functional programming interface
 * @export
 */
export const ProvidersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvidersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary A JSON array of providers.
         * @param {string} [query] 
         * @param {number} [year] 
         * @param {'amer' | 'apac' | 'emea'} [region] 
         * @param {'academicInstitution' | 'academicLibrary' | 'governmentAgency' | 'nationalInstitution' | 'nationalLibrary' | 'publisher' | 'professionalSociety' | 'researchInstitution' | 'serviceProvider' | 'vendor'} [organizationType] 
         * @param {'amer' | 'apac' | 'emea'} [focusArea] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {'relevance' | 'name' | '-name' | 'created' | '-created'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providersGet(query?: string, year?: number, region?: 'amer' | 'apac' | 'emea', organizationType?: 'academicInstitution' | 'academicLibrary' | 'governmentAgency' | 'nationalInstitution' | 'nationalLibrary' | 'publisher' | 'professionalSociety' | 'researchInstitution' | 'serviceProvider' | 'vendor', focusArea?: 'amer' | 'apac' | 'emea', pageNumber?: number, pageSize?: number, sort?: 'relevance' | 'name' | '-name' | 'created' | '-created', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providersGet(query, year, region, organizationType, focusArea, pageNumber, pageSize, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a provider.
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providersIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providersIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary A provider.
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providersIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providersIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a provider.
         * @param {string} id DOI
         * @param {Provider} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providersIdPut(id: string, provider: Provider, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providersIdPut(id, provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new provider.
         * @param {Provider} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providersPost(provider: Provider, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providersPost(provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns Providers DOI production statistics.
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providersTotalsGet(state?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providersTotalsGet(state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProvidersApi - factory interface
 * @export
 */
export const ProvidersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvidersApiFp(configuration)
    return {
        /**
         * 
         * @summary A JSON array of providers.
         * @param {string} [query] 
         * @param {number} [year] 
         * @param {'amer' | 'apac' | 'emea'} [region] 
         * @param {'academicInstitution' | 'academicLibrary' | 'governmentAgency' | 'nationalInstitution' | 'nationalLibrary' | 'publisher' | 'professionalSociety' | 'researchInstitution' | 'serviceProvider' | 'vendor'} [organizationType] 
         * @param {'amer' | 'apac' | 'emea'} [focusArea] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {'relevance' | 'name' | '-name' | 'created' | '-created'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersGet(query?: string, year?: number, region?: 'amer' | 'apac' | 'emea', organizationType?: 'academicInstitution' | 'academicLibrary' | 'governmentAgency' | 'nationalInstitution' | 'nationalLibrary' | 'publisher' | 'professionalSociety' | 'researchInstitution' | 'serviceProvider' | 'vendor', focusArea?: 'amer' | 'apac' | 'emea', pageNumber?: number, pageSize?: number, sort?: 'relevance' | 'name' | '-name' | 'created' | '-created', options?: any): AxiosPromise<Provider> {
            return localVarFp.providersGet(query, year, region, organizationType, focusArea, pageNumber, pageSize, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a provider.
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.providersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary A provider.
         * @param {string} id DOI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersIdGet(id: string, options?: any): AxiosPromise<Provider> {
            return localVarFp.providersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a provider.
         * @param {string} id DOI
         * @param {Provider} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersIdPut(id: string, provider: Provider, options?: any): AxiosPromise<void> {
            return localVarFp.providersIdPut(id, provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new provider.
         * @param {Provider} provider 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersPost(provider: Provider, options?: any): AxiosPromise<void> {
            return localVarFp.providersPost(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns Providers DOI production statistics.
         * @param {string} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providersTotalsGet(state?: string, options?: any): AxiosPromise<void> {
            return localVarFp.providersTotalsGet(state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvidersApi - object-oriented interface
 * @export
 * @class ProvidersApi
 * @extends {BaseAPI}
 */
export class ProvidersApi extends BaseAPI {
    /**
     * 
     * @summary A JSON array of providers.
     * @param {string} [query] 
     * @param {number} [year] 
     * @param {'amer' | 'apac' | 'emea'} [region] 
     * @param {'academicInstitution' | 'academicLibrary' | 'governmentAgency' | 'nationalInstitution' | 'nationalLibrary' | 'publisher' | 'professionalSociety' | 'researchInstitution' | 'serviceProvider' | 'vendor'} [organizationType] 
     * @param {'amer' | 'apac' | 'emea'} [focusArea] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {'relevance' | 'name' | '-name' | 'created' | '-created'} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public providersGet(query?: string, year?: number, region?: 'amer' | 'apac' | 'emea', organizationType?: 'academicInstitution' | 'academicLibrary' | 'governmentAgency' | 'nationalInstitution' | 'nationalLibrary' | 'publisher' | 'professionalSociety' | 'researchInstitution' | 'serviceProvider' | 'vendor', focusArea?: 'amer' | 'apac' | 'emea', pageNumber?: number, pageSize?: number, sort?: 'relevance' | 'name' | '-name' | 'created' | '-created', options?: AxiosRequestConfig) {
        return ProvidersApiFp(this.configuration).providersGet(query, year, region, organizationType, focusArea, pageNumber, pageSize, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a provider.
     * @param {string} id DOI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public providersIdDelete(id: string, options?: AxiosRequestConfig) {
        return ProvidersApiFp(this.configuration).providersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary A provider.
     * @param {string} id DOI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public providersIdGet(id: string, options?: AxiosRequestConfig) {
        return ProvidersApiFp(this.configuration).providersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a provider.
     * @param {string} id DOI
     * @param {Provider} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public providersIdPut(id: string, provider: Provider, options?: AxiosRequestConfig) {
        return ProvidersApiFp(this.configuration).providersIdPut(id, provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new provider.
     * @param {Provider} provider 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public providersPost(provider: Provider, options?: AxiosRequestConfig) {
        return ProvidersApiFp(this.configuration).providersPost(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns Providers DOI production statistics.
     * @param {string} [state] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvidersApi
     */
    public providersTotalsGet(state?: string, options?: AxiosRequestConfig) {
        return ProvidersApiFp(this.configuration).providersTotalsGet(state, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary A JSON array of reports.
         * @param {string} [platform] Name of the Platform the usage is being requested for. This can be omitted if the service provides usage for only one platform.
         * @param {string} [reportName] The long name of the report.
         * @param {string} [reportId] The report ID or code or shortname. Typically this will be the same code provided in the Report parameter of the request.
         * @param {string} [release] The release or version of the report.
         * @param {string} [created] Time the report was prepared. Format as defined by date-time - RFC3339
         * @param {string} [createdBy] Name of the organization producing the report.
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGet: async (platform?: string, reportName?: string, reportId?: string, release?: string, created?: string, createdBy?: string, pageNumber?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (reportName !== undefined) {
                localVarQueryParameter['report-name'] = reportName;
            }

            if (reportId !== undefined) {
                localVarQueryParameter['report-id'] = reportId;
            }

            if (release !== undefined) {
                localVarQueryParameter['release'] = release;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created-by'] = createdBy;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page[number]'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page[size]'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a report.
         * @param {string} id Report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reportsIdDelete', 'id', id)
            const localVarPath = `/reports/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary A report.
         * @param {string} id Report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reportsIdGet', 'id', id)
            const localVarPath = `/reports/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a report.
         * @param {string} id Report
         * @param {Report} report 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsIdPut: async (id: string, report: Report, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reportsIdPut', 'id', id)
            // verify required parameter 'report' is not null or undefined
            assertParamExists('reportsIdPut', 'report', report)
            const localVarPath = `/reports/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(report, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new report.
         * @param {Report} report 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsPost: async (report: Report, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'report' is not null or undefined
            assertParamExists('reportsPost', 'report', report)
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(report, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary A JSON array of reports.
         * @param {string} [platform] Name of the Platform the usage is being requested for. This can be omitted if the service provides usage for only one platform.
         * @param {string} [reportName] The long name of the report.
         * @param {string} [reportId] The report ID or code or shortname. Typically this will be the same code provided in the Report parameter of the request.
         * @param {string} [release] The release or version of the report.
         * @param {string} [created] Time the report was prepared. Format as defined by date-time - RFC3339
         * @param {string} [createdBy] Name of the organization producing the report.
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsGet(platform?: string, reportName?: string, reportId?: string, release?: string, created?: string, createdBy?: string, pageNumber?: number, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsGet(platform, reportName, reportId, release, created, createdBy, pageNumber, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a report.
         * @param {string} id Report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary A report.
         * @param {string} id Report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a report.
         * @param {string} id Report
         * @param {Report} report 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsIdPut(id: string, report: Report, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsIdPut(id, report, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a new report.
         * @param {Report} report 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsPost(report: Report, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsPost(report, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         * 
         * @summary A JSON array of reports.
         * @param {string} [platform] Name of the Platform the usage is being requested for. This can be omitted if the service provides usage for only one platform.
         * @param {string} [reportName] The long name of the report.
         * @param {string} [reportId] The report ID or code or shortname. Typically this will be the same code provided in the Report parameter of the request.
         * @param {string} [release] The release or version of the report.
         * @param {string} [created] Time the report was prepared. Format as defined by date-time - RFC3339
         * @param {string} [createdBy] Name of the organization producing the report.
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGet(platform?: string, reportName?: string, reportId?: string, release?: string, created?: string, createdBy?: string, pageNumber?: number, pageSize?: number, options?: any): AxiosPromise<Report> {
            return localVarFp.reportsGet(platform, reportName, reportId, release, created, createdBy, pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a report.
         * @param {string} id Report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.reportsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary A report.
         * @param {string} id Report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsIdGet(id: string, options?: any): AxiosPromise<Report> {
            return localVarFp.reportsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a report.
         * @param {string} id Report
         * @param {Report} report 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsIdPut(id: string, report: Report, options?: any): AxiosPromise<void> {
            return localVarFp.reportsIdPut(id, report, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new report.
         * @param {Report} report 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsPost(report: Report, options?: any): AxiosPromise<void> {
            return localVarFp.reportsPost(report, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * 
     * @summary A JSON array of reports.
     * @param {string} [platform] Name of the Platform the usage is being requested for. This can be omitted if the service provides usage for only one platform.
     * @param {string} [reportName] The long name of the report.
     * @param {string} [reportId] The report ID or code or shortname. Typically this will be the same code provided in the Report parameter of the request.
     * @param {string} [release] The release or version of the report.
     * @param {string} [created] Time the report was prepared. Format as defined by date-time - RFC3339
     * @param {string} [createdBy] Name of the organization producing the report.
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsGet(platform?: string, reportName?: string, reportId?: string, release?: string, created?: string, createdBy?: string, pageNumber?: number, pageSize?: number, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsGet(platform, reportName, reportId, release, created, createdBy, pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a report.
     * @param {string} id Report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsIdDelete(id: string, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary A report.
     * @param {string} id Report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsIdGet(id: string, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a report.
     * @param {string} id Report
     * @param {Report} report 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsIdPut(id: string, report: Report, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsIdPut(id, report, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new report.
     * @param {Report} report 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public reportsPost(report: Report, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).reportsPost(report, options).then((request) => request(this.axios, this.basePath));
    }
}


