/* tslint:disable */
/* eslint-disable */
/**
 * Turnitin Core API
 * Turnitin Core API (TCA) provides direct API access to the core functionality provided by Turnitin. TCA supports file submission, similarity report generation, group management, and visualization of report matches via Cloud Viewer or PDF download. Below is the full flow to successfully set up an integration scope, an API Key, and make calls to TCA. Integration Scope and API Key management is done via the Admin Console UI by logging in as an admin user. For more details, go to our [developer portal documentation page](https://developers.turnitin.com/docs). ## Integration Scope and API Key Management TCA API calls must provide an API Key for authentication, so you must first have at least one integration scope associated with at least one API Key to use TCA. ### Admin Console UI First, login to Admin Console UI as an *Admin* user with permission to create Integration Scopes, under a tenant that is licensed to use the TCA product Integration Scopes (you can create a new one, or add keys to existing)   * Click `Integrations` in the side bar --> `+ Add Integration` at top the top of the page --> Enter a name --> `Add` Button   API Keys   * Click `Integrations` in the side bar --> `Create API Key` Button next to a given Integration Scope -->   Enter a name --> click `Create and View button`   * Copy/Save the key manually or click save to clipboard button to copy it (this is the only time it will show) ## TCA Flow   *  Register a webhook   *  Create a submission   *  Upload a file for the submission   *  Wait for the submission upload to process      * If you registered a webhook, a callback will be sent to it when upload is complete      * The status of the *submission* will also update to `COMPLETE`   *  Request a Similarity Report   *  Wait for similarity report to process      * If you registered a webhook, a callback will be sent to it when report is complete      * The status of the *report* will also be updated to `COMPLETE`   *  Request a URL with parameters to view the Similarity Report 
 *
 * The version of the OpenAPI document: 1.0.226
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Request Object to add group attachment.
 * @export
 * @interface AddGroupAttachmentRequest
 */
export interface AddGroupAttachmentRequest {
    /**
     * Attachment title
     * @type {string}
     * @memberof AddGroupAttachmentRequest
     */
    'title'?: string;
    /**
     * template
     * @type {boolean}
     * @memberof AddGroupAttachmentRequest
     */
    'template'?: boolean;
}
/**
 * Object returned for add group attachment.
 * @export
 * @interface AddGroupAttachmentResponse
 */
export interface AddGroupAttachmentResponse {
    /**
     * Attachment uuid
     * @type {string}
     * @memberof AddGroupAttachmentResponse
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface AggregateGroup
 */
export interface AggregateGroup {
    /**
     * (required) 
     * @type {string}
     * @memberof AggregateGroup
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AggregateGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AggregateGroup
     */
    'type'?: AggregateGroupTypeEnum;
    /**
     * 
     * @type {GroupContext}
     * @memberof AggregateGroup
     */
    'group_context'?: GroupContext;
    /**
     * due date for the group
     * @type {string}
     * @memberof AggregateGroup
     */
    'due_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof AggregateGroup
     */
    'report_generation'?: AggregateGroupReportGenerationEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AggregateGroupTypeEnum {
    Assignment = 'ASSIGNMENT',
    Folder = 'FOLDER'
}
/**
    * @export
    * @enum {string}
    */
export enum AggregateGroupReportGenerationEnum {
    Immediately = 'IMMEDIATELY',
    ImmediatelyAndDueDate = 'IMMEDIATELY_AND_DUE_DATE'
}

/**
 * 
 * @export
 * @interface AuthorMetadataOverride
 */
export interface AuthorMetadataOverride {
    /**
     * Given or first name of submission author
     * @type {string}
     * @memberof AuthorMetadataOverride
     */
    'given_name'?: string;
    /**
     * Family or last name of submission author
     * @type {string}
     * @memberof AuthorMetadataOverride
     */
    'family_name'?: string;
}
/**
 * (optional) EULA acceptence information which either updates an existing acceptence or creates a new acceptence
 * @export
 * @interface Eula
 */
export interface Eula {
    /**
     * The timestamp marking when the EULA was accepted 
     * @type {string}
     * @memberof Eula
     */
    'accepted_timestamp'?: string;
    /**
     * The language code for which language instance of the EULA version was accepted 
     * @type {string}
     * @memberof Eula
     */
    'language'?: string;
    /**
     * The unique name of the EULA Version 
     * @type {string}
     * @memberof Eula
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface EulaAcceptListItem
 */
export interface EulaAcceptListItem {
    /**
     * The unique id of the user in the external system 
     * @type {string}
     * @memberof EulaAcceptListItem
     */
    'user_id'?: string;
    /**
     * The timestamp marking when the EULA was accepted 
     * @type {string}
     * @memberof EulaAcceptListItem
     */
    'accepted_timestamp'?: string;
    /**
     * The language code for which language instance of the EULA version was accepted 
     * @type {string}
     * @memberof EulaAcceptListItem
     */
    'language'?: string;
    /**
     * The unique name of the EULA Version 
     * @type {string}
     * @memberof EulaAcceptListItem
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface EulaAcceptRequest
 */
export interface EulaAcceptRequest {
    /**
     * The unique id of the user in the external system 
     * @type {string}
     * @memberof EulaAcceptRequest
     */
    'user_id'?: string;
    /**
     * The timestamp marking when the EULA was accepted 
     * @type {string}
     * @memberof EulaAcceptRequest
     */
    'accepted_timestamp'?: string;
    /**
     * The language code for which language instance of the EULA version was accepted 
     * @type {string}
     * @memberof EulaAcceptRequest
     */
    'language'?: string;
    /**
     * The unique name of the EULA Version 
     * @type {string}
     * @memberof EulaAcceptRequest
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface EulaVersion
 */
export interface EulaVersion {
    /**
     * The unique name of the EULA Version 
     * @type {string}
     * @memberof EulaVersion
     */
    'version'?: string;
    /**
     * The starting date indicating when acceptence of this EULA is considered valid 
     * @type {string}
     * @memberof EulaVersion
     */
    'valid_from'?: string;
    /**
     * The ending date indicating when acceptence of this EULA is no longer valid 
     * @type {string}
     * @memberof EulaVersion
     */
    'valid_until'?: string | null;
    /**
     * The url where the corresponding EULA page can be found 
     * @type {string}
     * @memberof EulaVersion
     */
    'url'?: string;
    /**
     * The languages (instances) of this version. 21 language locales are currently supported. 
     * @type {Array<string>}
     * @memberof EulaVersion
     */
    'available_languages'?: Array<EulaVersionAvailableLanguagesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum EulaVersionAvailableLanguagesEnum {
    ArSa = 'ar-SA',
    CsCz = 'cs-CZ',
    DaDk = 'da-DK',
    DeDe = 'de-DE',
    ElGr = 'el-GR',
    EnUs = 'en-US',
    EsMx = 'es-MX',
    FiFi = 'fi-FI',
    FrFr = 'fr-FR',
    ItIt = 'it-IT',
    JaJp = 'ja-JP',
    KoKr = 'ko-KR',
    NbNo = 'nb-NO',
    NlNl = 'nl-NL',
    PlPl = 'pl-PL',
    PtBr = 'pt-BR',
    RoRo = 'ro-RO',
    RuRu = 'ru-RU',
    SvSe = 'sv-SE',
    TrTr = 'tr-TR',
    ViVn = 'vi-VN',
    ZhCn = 'zh-CN',
    ZhTw = 'zh-TW'
}

/**
 * 
 * @export
 * @interface FeaturesEnabled
 */
export interface FeaturesEnabled {
    /**
     * 
     * @type {FeaturesSimilarity}
     * @memberof FeaturesEnabled
     */
    'similarity'?: FeaturesSimilarity;
    /**
     * 
     * @type {FeaturesTenant}
     * @memberof FeaturesEnabled
     */
    'tenant'?: FeaturesTenant;
    /**
     * 
     * @type {string}
     * @memberof FeaturesEnabled
     */
    'product_name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FeaturesEnabled
     */
    'access_options'?: Array<FeaturesEnabledAccessOptionsEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum FeaturesEnabledAccessOptionsEnum {
    Native = 'Native',
    CoreApi = 'CORE_API',
    DraftCoach = 'Draft Coach'
}

/**
 * 
 * @export
 * @interface FeaturesGenerationSettings
 */
export interface FeaturesGenerationSettings {
    /**
     * List of repositories to search
     * @type {Array<string>}
     * @memberof FeaturesGenerationSettings
     */
    'search_repositories'?: Array<FeaturesGenerationSettingsSearchRepositoriesEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof FeaturesGenerationSettings
     */
    'submission_auto_excludes'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum FeaturesGenerationSettingsSearchRepositoriesEnum {
    Internet = 'INTERNET',
    Publication = 'PUBLICATION',
    SubmittedWork = 'SUBMITTED_WORK',
    Private = 'PRIVATE',
    Crossref = 'CROSSREF',
    CrossrefPostedContent = 'CROSSREF_POSTED_CONTENT'
}

/**
 * 
 * @export
 * @interface FeaturesSimilarity
 */
export interface FeaturesSimilarity {
    /**
     * 
     * @type {FeaturesViewerModes}
     * @memberof FeaturesSimilarity
     */
    'viewer_modes'?: FeaturesViewerModes;
    /**
     * 
     * @type {FeaturesGenerationSettings}
     * @memberof FeaturesSimilarity
     */
    'generation_settings'?: FeaturesGenerationSettings;
    /**
     * 
     * @type {FeaturesSimilarityViewSettings}
     * @memberof FeaturesSimilarity
     */
    'view_settings'?: FeaturesSimilarityViewSettings;
}
/**
 * 
 * @export
 * @interface FeaturesSimilarityViewSettings
 */
export interface FeaturesSimilarityViewSettings {
    /**
     * If set to true, text in quotes will not count as similar content 
     * @type {boolean}
     * @memberof FeaturesSimilarityViewSettings
     */
    'exclude_quotes'?: boolean;
    /**
     * If set to true, text in a bibliography section will not count as similar content 
     * @type {boolean}
     * @memberof FeaturesSimilarityViewSettings
     */
    'exclude_bibliography'?: boolean;
    /**
     * If set to true, text in citations will not count as similar content 
     * @type {boolean}
     * @memberof FeaturesSimilarityViewSettings
     */
    'exclude_citations'?: boolean;
    /**
     * If set to true, text in the abstract section of the submission will not count as similar content 
     * @type {boolean}
     * @memberof FeaturesSimilarityViewSettings
     */
    'exclude_abstract'?: boolean;
    /**
     * If set to true, text in the method section of the submission will not count as similar content 
     * @type {boolean}
     * @memberof FeaturesSimilarityViewSettings
     */
    'exclude_methods'?: boolean;
    /**
     * If set, similarity matches that match less than the specified amount of words will not count as similar content 
     * @type {boolean}
     * @memberof FeaturesSimilarityViewSettings
     */
    'exclude_small_matches'?: boolean;
    /**
     * If set to true, text matched to the internet collection will not count as similar content 
     * @type {boolean}
     * @memberof FeaturesSimilarityViewSettings
     */
    'exclude_internet'?: boolean;
    /**
     * If set to true, text matched to the publications collection will not count as similar content 
     * @type {boolean}
     * @memberof FeaturesSimilarityViewSettings
     */
    'exclude_publications'?: boolean;
    /**
     * If set to true, text matched to the Crossref collection will not count as similar content 
     * @type {boolean}
     * @memberof FeaturesSimilarityViewSettings
     */
    'exclude_crossref'?: boolean;
    /**
     * If set to true, text matched to the Crossref Posted Content collection will not count as similar content 
     * @type {boolean}
     * @memberof FeaturesSimilarityViewSettings
     */
    'exclude_crossref_posted_content'?: boolean;
    /**
     * If set to true, text matched to the submitted works collection will not count as similar content calculated as if submitted work was not part of the paper 
     * @type {boolean}
     * @memberof FeaturesSimilarityViewSettings
     */
    'exclude_submitted_works'?: boolean;
    /**
     * If set to true, text matched to the custom sections defined in the admin settings will not count as similar content calculated as if section was not part of the paper 
     * @type {boolean}
     * @memberof FeaturesSimilarityViewSettings
     */
    'exclude_custom_sections'?: boolean;
    /**
     * If set to true, it will exclude preprints. A preprint is a version of a scholarly or scientific paper that precedes formal peer review and publication in a peer-reviewed scholarly or scientific journal. 
     * @type {boolean}
     * @memberof FeaturesSimilarityViewSettings
     */
    'exclude_preprints'?: boolean;
}
/**
 * 
 * @export
 * @interface FeaturesTenant
 */
export interface FeaturesTenant {
    /**
     * a flag indicating whether this tenant requires EULA checks to use this API
     * @type {boolean}
     * @memberof FeaturesTenant
     */
    'require_eula'?: boolean;
}
/**
 * 
 * @export
 * @interface FeaturesViewerModes
 */
export interface FeaturesViewerModes {
    /**
     * 
     * @type {boolean}
     * @memberof FeaturesViewerModes
     */
    'match_overview'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeaturesViewerModes
     */
    'all_sources'?: boolean;
}
/**
 * 
 * @export
 * @interface GetGroupAttachments200Response
 */
export interface GetGroupAttachments200Response {
    /**
     * 
     * @type {Array<GroupAttachmentResponse>}
     * @memberof GetGroupAttachments200Response
     */
    'attachments'?: Array<GroupAttachmentResponse>;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * (required) 
     * @type {string}
     * @memberof Group
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'type'?: GroupTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum GroupTypeEnum {
    Assignment = 'ASSIGNMENT',
    Folder = 'FOLDER'
}

/**
 * Object returned for group attachment.
 * @export
 * @interface GroupAttachmentResponse
 */
export interface GroupAttachmentResponse {
    /**
     * uuid
     * @type {string}
     * @memberof GroupAttachmentResponse
     */
    'id'?: string;
    /**
     * title
     * @type {string}
     * @memberof GroupAttachmentResponse
     */
    'title'?: string;
    /**
     * status
     * @type {string}
     * @memberof GroupAttachmentResponse
     */
    'status'?: GroupAttachmentResponseStatusEnum;
    /**
     * template
     * @type {boolean}
     * @memberof GroupAttachmentResponse
     */
    'template'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum GroupAttachmentResponseStatusEnum {
    Created = 'CREATED',
    Processing = 'PROCESSING',
    Complete = 'COMPLETE',
    Error = 'ERROR',
    Delete = 'DELETE'
}

/**
 * 
 * @export
 * @interface GroupContext
 */
export interface GroupContext {
    /**
     * (required) 
     * @type {string}
     * @memberof GroupContext
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupContext
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Users>}
     * @memberof GroupContext
     */
    'owners'?: Array<Users>;
}
/**
 * 
 * @export
 * @interface IndexStateSettings
 */
export interface IndexStateSettings {
    /**
     * If true, is_indexed displays the index state of submission. 
     * @type {boolean}
     * @memberof IndexStateSettings
     */
    'is_indexed'?: boolean;
}
/**
 * 
 * @export
 * @interface IndexingSettings
 */
export interface IndexingSettings {
    /**
     * If set, the submission will be added to all valid node groups for future matching
     * @type {boolean}
     * @memberof IndexingSettings
     */
    'add_to_index'?: boolean;
}
/**
 * The generic object returned for errors. Updated for recent TCA changes.
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * an HTTP Response JobStatus Code
     * @type {string}
     * @memberof ModelError
     */
    'status'?: string;
    /**
     * A message explaining what happened
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface PDFStatusWebhookRequest
 */
export interface PDFStatusWebhookRequest {
    /**
     * The requesting Pdf status
     * @type {string}
     * @memberof PDFStatusWebhookRequest
     */
    'status'?: PDFStatusWebhookRequestStatusEnum;
    /**
     * the PDF ID
     * @type {string}
     * @memberof PDFStatusWebhookRequest
     */
    'id'?: string;
    /**
     * the associated submission ID
     * @type {string}
     * @memberof PDFStatusWebhookRequest
     */
    'submission_id'?: string;
    /**
     * 
     * @type {SubmissionCompleteWebhookRequestAllOfMetadata}
     * @memberof PDFStatusWebhookRequest
     */
    'metadata'?: SubmissionCompleteWebhookRequestAllOfMetadata;
}

/**
    * @export
    * @enum {string}
    */
export enum PDFStatusWebhookRequestStatusEnum {
    Success = 'SUCCESS',
    Pending = 'PENDING',
    Failed = 'FAILED'
}

/**
 * 
 * @export
 * @interface PdfStatusResponse
 */
export interface PdfStatusResponse {
    /**
     * The requesting Pdf status
     * @type {string}
     * @memberof PdfStatusResponse
     */
    'status'?: PdfStatusResponseStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum PdfStatusResponseStatusEnum {
    Success = 'SUCCESS',
    Pending = 'PENDING',
    Failed = 'FAILED'
}

/**
 * 
 * @export
 * @interface RateLimitError
 */
export interface RateLimitError {
    /**
     * an HTTP Response JobStatus Code
     * @type {string}
     * @memberof RateLimitError
     */
    'status'?: string;
    /**
     * A message explaining what happened
     * @type {string}
     * @memberof RateLimitError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface RequestPdfResponse
 */
export interface RequestPdfResponse {
    /**
     * The Pdf ID
     * @type {string}
     * @memberof RequestPdfResponse
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface Sidebar
 */
export interface Sidebar {
    /**
     * The default mode shown in the sidebar panel. The selected mode must be enabled in the tenant\'s license, request parameter, as well as the viewer\'s permission. The default mode is similarity. 
     * @type {string}
     * @memberof Sidebar
     */
    'default_mode'?: SidebarDefaultModeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SidebarDefaultModeEnum {
    Similarity = 'similarity',
    Flags = 'flags',
    DocumentDetails = 'documentDetails',
    SectionsExclusion = 'sections_exclusion'
}

/**
 * 
 * @export
 * @interface SimilarityCompleteWebhookRequest
 */
export interface SimilarityCompleteWebhookRequest {
    /**
     * Represents the percentage match against all sources
     * @type {number}
     * @memberof SimilarityCompleteWebhookRequest
     */
    'overall_match_percentage': number;
    /**
     * Represents the percentage match against internet
     * @type {number}
     * @memberof SimilarityCompleteWebhookRequest
     */
    'internet_match_percentage'?: number | null;
    /**
     * Represents the percentage match against all publications
     * @type {number}
     * @memberof SimilarityCompleteWebhookRequest
     */
    'publication_match_percentage'?: number | null;
    /**
     * Represents the percentage match against all submitted works
     * @type {number}
     * @memberof SimilarityCompleteWebhookRequest
     */
    'submitted_works_match_percentage'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SimilarityCompleteWebhookRequest
     */
    'submission_id': string;
    /**
     * possible values PENDING, COMPLETE
     * @type {string}
     * @memberof SimilarityCompleteWebhookRequest
     */
    'status': string;
    /**
     * Time the report finished generating.  If not set the report has not finished generating
     * @type {string}
     * @memberof SimilarityCompleteWebhookRequest
     */
    'time_generated': string;
    /**
     * Time the report was requested
     * @type {string}
     * @memberof SimilarityCompleteWebhookRequest
     */
    'time_requested': string;
    /**
     * Top matches
     * @type {Array<SimilarityMetadataAllOfTopMatches>}
     * @memberof SimilarityCompleteWebhookRequest
     */
    'top_matches': Array<SimilarityMetadataAllOfTopMatches>;
    /**
     * Largest individual matched word count, 0 if there isn\'t a match to this submission.
     * @type {number}
     * @memberof SimilarityCompleteWebhookRequest
     */
    'top_source_largest_matched_word_count': number;
    /**
     * 
     * @type {SubmissionCompleteWebhookRequestAllOfMetadata}
     * @memberof SimilarityCompleteWebhookRequest
     */
    'metadata'?: SubmissionCompleteWebhookRequestAllOfMetadata;
}
/**
 * 
 * @export
 * @interface SimilarityGenerationSettings
 */
export interface SimilarityGenerationSettings {
    /**
     * List of repositories to search
     * @type {Array<string>}
     * @memberof SimilarityGenerationSettings
     */
    'search_repositories': Array<SimilarityGenerationSettingsSearchRepositoriesEnum>;
    /**
     * List of submission IDs to exclude from report
     * @type {Array<string>}
     * @memberof SimilarityGenerationSettings
     */
    'submission_auto_excludes'?: Array<string>;
    /**
     * self matching submissions to exclude from report
     * @type {string}
     * @memberof SimilarityGenerationSettings
     */
    'auto_exclude_self_matching_scope'?: SimilarityGenerationSettingsAutoExcludeSelfMatchingScopeEnum;
    /**
     * Priority level of report generation
     * @type {boolean}
     * @memberof SimilarityGenerationSettings
     */
    'priority'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum SimilarityGenerationSettingsSearchRepositoriesEnum {
    Internet = 'INTERNET',
    Publication = 'PUBLICATION',
    SubmittedWork = 'SUBMITTED_WORK',
    Private = 'PRIVATE',
    Crossref = 'CROSSREF',
    CrossrefPostedContent = 'CROSSREF_POSTED_CONTENT'
}
/**
    * @export
    * @enum {string}
    */
export enum SimilarityGenerationSettingsAutoExcludeSelfMatchingScopeEnum {
    All = 'ALL',
    Group = 'GROUP',
    GroupContext = 'GROUP_CONTEXT',
    None = 'NONE'
}

/**
 * 
 * @export
 * @interface SimilarityMetadata
 */
export interface SimilarityMetadata {
    /**
     * Represents the percentage match against all sources
     * @type {number}
     * @memberof SimilarityMetadata
     */
    'overall_match_percentage': number;
    /**
     * Represents the percentage match against internet
     * @type {number}
     * @memberof SimilarityMetadata
     */
    'internet_match_percentage'?: number | null;
    /**
     * Represents the percentage match against all publications
     * @type {number}
     * @memberof SimilarityMetadata
     */
    'publication_match_percentage'?: number | null;
    /**
     * Represents the percentage match against all submitted works
     * @type {number}
     * @memberof SimilarityMetadata
     */
    'submitted_works_match_percentage'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SimilarityMetadata
     */
    'submission_id': string;
    /**
     * possible values PENDING, COMPLETE
     * @type {string}
     * @memberof SimilarityMetadata
     */
    'status': string;
    /**
     * Time the report finished generating.  If not set the report has not finished generating
     * @type {string}
     * @memberof SimilarityMetadata
     */
    'time_generated': string;
    /**
     * Time the report was requested
     * @type {string}
     * @memberof SimilarityMetadata
     */
    'time_requested': string;
    /**
     * Top matches
     * @type {Array<SimilarityMetadataAllOfTopMatches>}
     * @memberof SimilarityMetadata
     */
    'top_matches': Array<SimilarityMetadataAllOfTopMatches>;
    /**
     * Largest individual matched word count, 0 if there isn\'t a match to this submission.
     * @type {number}
     * @memberof SimilarityMetadata
     */
    'top_source_largest_matched_word_count': number;
}
/**
 * 
 * @export
 * @interface SimilarityMetadataAllOf
 */
export interface SimilarityMetadataAllOf {
    /**
     * 
     * @type {string}
     * @memberof SimilarityMetadataAllOf
     */
    'submission_id': string;
    /**
     * possible values PENDING, COMPLETE
     * @type {string}
     * @memberof SimilarityMetadataAllOf
     */
    'status': string;
    /**
     * Time the report finished generating.  If not set the report has not finished generating
     * @type {string}
     * @memberof SimilarityMetadataAllOf
     */
    'time_generated': string;
    /**
     * Time the report was requested
     * @type {string}
     * @memberof SimilarityMetadataAllOf
     */
    'time_requested': string;
    /**
     * Top matches
     * @type {Array<SimilarityMetadataAllOfTopMatches>}
     * @memberof SimilarityMetadataAllOf
     */
    'top_matches': Array<SimilarityMetadataAllOfTopMatches>;
    /**
     * Largest individual matched word count, 0 if there isn\'t a match to this submission.
     * @type {number}
     * @memberof SimilarityMetadataAllOf
     */
    'top_source_largest_matched_word_count': number;
}
/**
 * 
 * @export
 * @interface SimilarityMetadataAllOfTopMatches
 */
export interface SimilarityMetadataAllOfTopMatches {
    /**
     * Source name
     * @type {string}
     * @memberof SimilarityMetadataAllOfTopMatches
     */
    'name'?: string;
    /**
     * Match percentage
     * @type {number}
     * @memberof SimilarityMetadataAllOfTopMatches
     */
    'percentage'?: number;
    /**
     * Matching submission id
     * @type {string}
     * @memberof SimilarityMetadataAllOfTopMatches
     */
    'submission_id'?: string;
    /**
     * Matching submission source type (INTERNET, PUBLICATION, SUBMITTED_WORK)
     * @type {string}
     * @memberof SimilarityMetadataAllOfTopMatches
     */
    'source_type'?: string;
    /**
     * number of matching words
     * @type {number}
     * @memberof SimilarityMetadataAllOfTopMatches
     */
    'matched_word_count_total'?: number;
    /**
     * date match was submitted
     * @type {string}
     * @memberof SimilarityMetadataAllOfTopMatches
     */
    'submitted_date'?: string;
    /**
     * intitution name for matched SUBMITTED_WORK types
     * @type {string}
     * @memberof SimilarityMetadataAllOfTopMatches
     */
    'institution_name'?: string;
}
/**
 * 
 * @export
 * @interface SimilarityPutRequest
 */
export interface SimilarityPutRequest {
    /**
     * 
     * @type {IndexingSettings}
     * @memberof SimilarityPutRequest
     */
    'indexing_settings'?: IndexingSettings;
    /**
     * 
     * @type {SimilarityGenerationSettings}
     * @memberof SimilarityPutRequest
     */
    'generation_settings': SimilarityGenerationSettings;
    /**
     * 
     * @type {SimilarityViewSettings}
     * @memberof SimilarityPutRequest
     */
    'view_settings'?: SimilarityViewSettings;
}
/**
 * 
 * @export
 * @interface SimilarityScoreData
 */
export interface SimilarityScoreData {
    /**
     * Represents the percentage match against all sources
     * @type {number}
     * @memberof SimilarityScoreData
     */
    'overall_match_percentage': number;
    /**
     * Represents the percentage match against internet
     * @type {number}
     * @memberof SimilarityScoreData
     */
    'internet_match_percentage'?: number | null;
    /**
     * Represents the percentage match against all publications
     * @type {number}
     * @memberof SimilarityScoreData
     */
    'publication_match_percentage'?: number | null;
    /**
     * Represents the percentage match against all submitted works
     * @type {number}
     * @memberof SimilarityScoreData
     */
    'submitted_works_match_percentage'?: number | null;
}
/**
 * 
 * @export
 * @interface SimilaritySettings
 */
export interface SimilaritySettings {
    /**
     * 
     * @type {SimilaritySettingsModes}
     * @memberof SimilaritySettings
     */
    'modes'?: SimilaritySettingsModes;
    /**
     * 
     * @type {SimilaritySettingsViewSettings}
     * @memberof SimilaritySettings
     */
    'view_settings'?: SimilaritySettingsViewSettings;
}
/**
 * 
 * @export
 * @interface SimilaritySettingsModes
 */
export interface SimilaritySettingsModes {
    /**
     * Used to enable use of the match overview mode in the viewer
     * @type {boolean}
     * @memberof SimilaritySettingsModes
     */
    'match_overview'?: boolean;
    /**
     * Used to enable use of the all sources mode in the viewer
     * @type {boolean}
     * @memberof SimilaritySettingsModes
     */
    'all_sources'?: boolean;
}
/**
 * 
 * @export
 * @interface SimilaritySettingsViewSettings
 */
export interface SimilaritySettingsViewSettings {
    /**
     * Used to enable save changes in the Viewer and trigger SIMILARITY_UPDATED webhook callback
     * @type {boolean}
     * @memberof SimilaritySettingsViewSettings
     */
    'save_changes'?: boolean;
}
/**
 * 
 * @export
 * @interface SimilarityViewSettings
 */
export interface SimilarityViewSettings {
    /**
     * If set to true, text in quotes will not count as similar content 
     * @type {boolean}
     * @memberof SimilarityViewSettings
     */
    'exclude_quotes'?: boolean;
    /**
     * If set to true, text in a bibliography section will not count as similar content 
     * @type {boolean}
     * @memberof SimilarityViewSettings
     */
    'exclude_bibliography'?: boolean;
    /**
     * If set to true, text in citations will not count as similar content 
     * @type {boolean}
     * @memberof SimilarityViewSettings
     */
    'exclude_citations'?: boolean;
    /**
     * If set to true, text in the abstract section of the submission will not count as similar content 
     * @type {boolean}
     * @memberof SimilarityViewSettings
     */
    'exclude_abstract'?: boolean;
    /**
     * If set to true, text in the method section of the submission will not count as similar content 
     * @type {boolean}
     * @memberof SimilarityViewSettings
     */
    'exclude_methods'?: boolean;
    /**
     * If set, similarity matches that match less than the specified amount of words will not count as similar content 
     * @type {number}
     * @memberof SimilarityViewSettings
     */
    'exclude_small_matches'?: number;
    /**
     * If set to true, text matched to the internet collection will not count as similar content 
     * @type {boolean}
     * @memberof SimilarityViewSettings
     */
    'exclude_internet'?: boolean;
    /**
     * If set to true, text matched to the publications collection will not count as similar content 
     * @type {boolean}
     * @memberof SimilarityViewSettings
     */
    'exclude_publications'?: boolean;
    /**
     * If set to true, text matched to the Crossref collection will not count as similar content 
     * @type {boolean}
     * @memberof SimilarityViewSettings
     */
    'exclude_crossref'?: boolean;
    /**
     * If set to true, text matched to the Crossref Posted Content collection will not count as similar content 
     * @type {boolean}
     * @memberof SimilarityViewSettings
     */
    'exclude_crossref_posted_content'?: boolean;
    /**
     * If set to true, text matched to the submitted works collection will not count as similar content calculated as if submitted work was not part of the paper 
     * @type {boolean}
     * @memberof SimilarityViewSettings
     */
    'exclude_submitted_works'?: boolean;
    /**
     * If set to true, text matched to the custom sections defined in the admin settings will not count as similar content calculated as if section was not part of the paper 
     * @type {boolean}
     * @memberof SimilarityViewSettings
     */
    'exclude_custom_sections'?: boolean;
    /**
     * If set to true, it will exclude preprints. A preprint is a version of a scholarly or scientific paper that precedes formal peer review and publication in a peer-reviewed scholarly or scientific journal. 
     * @type {boolean}
     * @memberof SimilarityViewSettings
     */
    'exclude_preprints'?: boolean;
}
/**
 * 
 * @export
 * @interface SimilarityViewerUrlResponse
 */
export interface SimilarityViewerUrlResponse {
    /**
     * URL to be used to access Cloud Viewer visualization of similarity report matches
     * @type {string}
     * @memberof SimilarityViewerUrlResponse
     */
    'viewer_url'?: string;
}
/**
 * 
 * @export
 * @interface SimilarityViewerUrlSettings
 */
export interface SimilarityViewerUrlSettings {
    /**
     * 
     * @type {AuthorMetadataOverride}
     * @memberof SimilarityViewerUrlSettings
     */
    'author_metadata_override'?: AuthorMetadataOverride;
    /**
     * viewer\'s user ID
     * @type {string}
     * @memberof SimilarityViewerUrlSettings
     */
    'viewer_user_id'?: string;
    /**
     * two character locale language setting (e.g. \'en\' or \'de\') or full value
     * @type {string}
     * @memberof SimilarityViewerUrlSettings
     */
    'locale'?: SimilarityViewerUrlSettingsLocaleEnum;
    /**
     * Default viewer permission set, accepts INSTRUCTOR, LEARNER, EDITOR, USER, APPLICANT, ADMINISTRATOR, UNDEFINED
     * @type {string}
     * @memberof SimilarityViewerUrlSettings
     */
    'viewer_default_permission_set'?: string;
    /**
     * 
     * @type {ViewerPermissions}
     * @memberof SimilarityViewerUrlSettings
     */
    'viewer_permissions'?: ViewerPermissions;
    /**
     * 
     * @type {Eula}
     * @memberof SimilarityViewerUrlSettings
     */
    'eula'?: Eula;
    /**
     * 
     * @type {Sidebar}
     * @memberof SimilarityViewerUrlSettings
     */
    'sidebar'?: Sidebar;
    /**
     * 
     * @type {SimilaritySettings}
     * @memberof SimilarityViewerUrlSettings
     */
    'similarity'?: SimilaritySettings;
}

/**
    * @export
    * @enum {string}
    */
export enum SimilarityViewerUrlSettingsLocaleEnum {
    ArSa = 'ar-SA',
    CsCz = 'cs-CZ',
    DeDe = 'de-DE',
    ElGr = 'el-GR',
    EnUs = 'en-US',
    EsMx = 'es-MX',
    FiFi = 'fi-FI',
    FrFr = 'fr-FR',
    ItIt = 'it-IT',
    JaJp = 'ja-JP',
    KoKr = 'ko-KR',
    NlNl = 'nl-NL',
    PlPl = 'pl-PL',
    PtBr = 'pt-BR',
    RoRo = 'ro-RO',
    RuRu = 'ru-RU',
    SvSe = 'sv-SE',
    TrTr = 'tr-TR',
    ViVn = 'vi-VN',
    ZhCn = 'zh-CN',
    ZhTw = 'zh-TW'
}

/**
 * 
 * @export
 * @interface SimpleSubmissionResponse
 */
export interface SimpleSubmissionResponse {
    /**
     * the unique ID of the submission
     * @type {string}
     * @memberof SimpleSubmissionResponse
     */
    'id'?: string;
    /**
     * the owner of the submission
     * @type {string}
     * @memberof SimpleSubmissionResponse
     */
    'owner'?: string;
    /**
     * the title of the submission
     * @type {string}
     * @memberof SimpleSubmissionResponse
     */
    'title'?: string;
    /**
     * the current status of the Submission
     * @type {string}
     * @memberof SimpleSubmissionResponse
     */
    'status'?: SimpleSubmissionResponseStatusEnum;
    /**
     * RFC3339 timestamp of when this submission was initially created. This is the time at which the POST to /submissions was made. 
     * @type {string}
     * @memberof SimpleSubmissionResponse
     */
    'created_time'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SimpleSubmissionResponseStatusEnum {
    Created = 'CREATED',
    Processing = 'PROCESSING',
    Complete = 'COMPLETE'
}

/**
 * 
 * @export
 * @interface SimpleSubmissionResponseAllOf
 */
export interface SimpleSubmissionResponseAllOf {
    /**
     * the unique ID of the submission
     * @type {string}
     * @memberof SimpleSubmissionResponseAllOf
     */
    'id'?: string;
    /**
     * the owner of the submission
     * @type {string}
     * @memberof SimpleSubmissionResponseAllOf
     */
    'owner'?: string;
    /**
     * the title of the submission
     * @type {string}
     * @memberof SimpleSubmissionResponseAllOf
     */
    'title'?: string;
    /**
     * the current status of the Submission
     * @type {string}
     * @memberof SimpleSubmissionResponseAllOf
     */
    'status'?: SimpleSubmissionResponseAllOfStatusEnum;
    /**
     * RFC3339 timestamp of when this submission was initially created. This is the time at which the POST to /submissions was made. 
     * @type {string}
     * @memberof SimpleSubmissionResponseAllOf
     */
    'created_time'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SimpleSubmissionResponseAllOfStatusEnum {
    Created = 'CREATED',
    Processing = 'PROCESSING',
    Complete = 'COMPLETE'
}

/**
 * 
 * @export
 * @interface Submission
 */
export interface Submission {
    /**
     * the owner of the submission
     * @type {string}
     * @memberof Submission
     */
    'owner'?: string;
    /**
     * the title of the submission
     * @type {string}
     * @memberof Submission
     */
    'title'?: string;
    /**
     * the current status of the Submission
     * @type {string}
     * @memberof Submission
     */
    'status'?: SubmissionStatusEnum;
    /**
     * the unique ID of the submission
     * @type {string}
     * @memberof Submission
     */
    'id'?: string;
    /**
     * the content type of the submission
     * @type {string}
     * @memberof Submission
     */
    'content_type'?: string;
    /**
     * the number of pages in the submission
     * @type {number}
     * @memberof Submission
     */
    'page_count'?: number;
    /**
     * the number of words in the submission
     * @type {number}
     * @memberof Submission
     */
    'word_count'?: number;
    /**
     * the number of characters in the submission
     * @type {number}
     * @memberof Submission
     */
    'character_count'?: number;
    /**
     * an error code representing the type of error encountered (if applicable) 
     * @type {string}
     * @memberof Submission
     */
    'error_code'?: SubmissionErrorCodeEnum;
    /**
     * RFC3339 timestamp of when this submission was initially created. This is the time at which the POST to /submissions was made. 
     * @type {string}
     * @memberof Submission
     */
    'created_time'?: string;
    /**
     * Set of capabilities available to the current submission
     * @type {Array<string>}
     * @memberof Submission
     */
    'capabilities'?: Array<SubmissionCapabilitiesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum SubmissionStatusEnum {
    Created = 'CREATED',
    Processing = 'PROCESSING',
    Completed = 'COMPLETED'
}
/**
    * @export
    * @enum {string}
    */
export enum SubmissionErrorCodeEnum {
    UnsupportedFiletype = 'UNSUPPORTED_FILETYPE',
    ProcessingError = 'PROCESSING_ERROR',
    CannotExtractText = 'CANNOT_EXTRACT_TEXT',
    TooLittleText = 'TOO_LITTLE_TEXT',
    TooMuchText = 'TOO_MUCH_TEXT',
    TooManyPages = 'TOO_MANY_PAGES',
    FileLocked = 'FILE_LOCKED',
    CorruptFile = 'CORRUPT_FILE'
}
/**
    * @export
    * @enum {string}
    */
export enum SubmissionCapabilitiesEnum {
    Index = 'INDEX',
    Similarity = 'SIMILARITY',
    Viewer = 'VIEWER'
}

/**
 * 
 * @export
 * @interface SubmissionAllOf
 */
export interface SubmissionAllOf {
    /**
     * the owner of the submission
     * @type {string}
     * @memberof SubmissionAllOf
     */
    'owner'?: string;
    /**
     * the title of the submission
     * @type {string}
     * @memberof SubmissionAllOf
     */
    'title'?: string;
    /**
     * the current status of the Submission
     * @type {string}
     * @memberof SubmissionAllOf
     */
    'status'?: SubmissionAllOfStatusEnum;
    /**
     * the unique ID of the submission
     * @type {string}
     * @memberof SubmissionAllOf
     */
    'id'?: string;
    /**
     * the content type of the submission
     * @type {string}
     * @memberof SubmissionAllOf
     */
    'content_type'?: string;
    /**
     * the number of pages in the submission
     * @type {number}
     * @memberof SubmissionAllOf
     */
    'page_count'?: number;
    /**
     * the number of words in the submission
     * @type {number}
     * @memberof SubmissionAllOf
     */
    'word_count'?: number;
    /**
     * the number of characters in the submission
     * @type {number}
     * @memberof SubmissionAllOf
     */
    'character_count'?: number;
    /**
     * an error code representing the type of error encountered (if applicable) 
     * @type {string}
     * @memberof SubmissionAllOf
     */
    'error_code'?: SubmissionAllOfErrorCodeEnum;
    /**
     * RFC3339 timestamp of when this submission was initially created. This is the time at which the POST to /submissions was made. 
     * @type {string}
     * @memberof SubmissionAllOf
     */
    'created_time'?: string;
    /**
     * Set of capabilities available to the current submission
     * @type {Array<string>}
     * @memberof SubmissionAllOf
     */
    'capabilities'?: Array<SubmissionAllOfCapabilitiesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum SubmissionAllOfStatusEnum {
    Created = 'CREATED',
    Processing = 'PROCESSING',
    Completed = 'COMPLETED'
}
/**
    * @export
    * @enum {string}
    */
export enum SubmissionAllOfErrorCodeEnum {
    UnsupportedFiletype = 'UNSUPPORTED_FILETYPE',
    ProcessingError = 'PROCESSING_ERROR',
    CannotExtractText = 'CANNOT_EXTRACT_TEXT',
    TooLittleText = 'TOO_LITTLE_TEXT',
    TooMuchText = 'TOO_MUCH_TEXT',
    TooManyPages = 'TOO_MANY_PAGES',
    FileLocked = 'FILE_LOCKED',
    CorruptFile = 'CORRUPT_FILE'
}
/**
    * @export
    * @enum {string}
    */
export enum SubmissionAllOfCapabilitiesEnum {
    Index = 'INDEX',
    Similarity = 'SIMILARITY',
    Viewer = 'VIEWER'
}

/**
 * A Submission is the base object on which other services (such as similarity) are offered. In order to use other services a Submission must first be created and successfully process, then other service objects can be created. 
 * @export
 * @interface SubmissionBase
 */
export interface SubmissionBase {
    /**
     * ID of the owning user
     * @type {string}
     * @memberof SubmissionBase
     */
    'owner'?: string;
    /**
     * Default viewer permission set, accepts INSTRUCTOR, LEARNER, EDITOR, USER, APPLICANT, ADMINISTRATOR, UNDEFINED
     * @type {string}
     * @memberof SubmissionBase
     */
    'owner_default_permission_set'?: SubmissionBaseOwnerDefaultPermissionSetEnum;
    /**
     * the title of the submission
     * @type {string}
     * @memberof SubmissionBase
     */
    'title'?: string;
    /**
     * (optional) ID of the submitting user, if different from the owning user
     * @type {string}
     * @memberof SubmissionBase
     */
    'submitter'?: string;
    /**
     * Default submitter permission set, accepts INSTRUCTOR, LEARNER, EDITOR, USER, APPLICANT, ADMINISTRATOR, UNDEFINED
     * @type {string}
     * @memberof SubmissionBase
     */
    'submitter_default_permission_set'?: SubmissionBaseSubmitterDefaultPermissionSetEnum;
    /**
     * 
     * @type {Eula}
     * @memberof SubmissionBase
     */
    'eula'?: Eula;
    /**
     * 
     * @type {SubmissionBaseMetadata}
     * @memberof SubmissionBase
     */
    'metadata'?: SubmissionBaseMetadata;
    /**
     * (optional) indicates if the submission should be treated as a text only submission. A text only submission cannot generate full reports or be viewed in the viewer, but can use the index only endpoint to be indexed
     * @type {boolean}
     * @memberof SubmissionBase
     */
    'extract_text_only'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum SubmissionBaseOwnerDefaultPermissionSetEnum {
    Instructor = 'INSTRUCTOR',
    Learner = 'LEARNER',
    Editor = 'EDITOR',
    User = 'USER',
    Applicant = 'APPLICANT',
    Administrator = 'ADMINISTRATOR',
    Undefined = 'UNDEFINED'
}
/**
    * @export
    * @enum {string}
    */
export enum SubmissionBaseSubmitterDefaultPermissionSetEnum {
    Instructor = 'INSTRUCTOR',
    Learner = 'LEARNER',
    Editor = 'EDITOR',
    User = 'USER',
    Applicant = 'APPLICANT',
    Administrator = 'ADMINISTRATOR',
    Undefined = 'UNDEFINED'
}

/**
 * (optional) Submission metadata. If a group context is included, it must be associated to a group
 * @export
 * @interface SubmissionBaseMetadata
 */
export interface SubmissionBaseMetadata {
    /**
     * 
     * @type {Users}
     * @memberof SubmissionBaseMetadata
     */
    'submitter'?: Users;
    /**
     * 
     * @type {Array<Users>}
     * @memberof SubmissionBaseMetadata
     */
    'owners'?: Array<Users>;
    /**
     * 
     * @type {Group}
     * @memberof SubmissionBaseMetadata
     */
    'group'?: Group;
    /**
     * 
     * @type {GroupContext}
     * @memberof SubmissionBaseMetadata
     */
    'group_context'?: GroupContext;
    /**
     * Optional original submision date
     * @type {string}
     * @memberof SubmissionBaseMetadata
     */
    'original_submitted_time'?: string;
    /**
     * custom metadata
     * @type {string}
     * @memberof SubmissionBaseMetadata
     */
    'custom'?: string;
}
/**
 * 
 * @export
 * @interface SubmissionCompleteWebhookRequest
 */
export interface SubmissionCompleteWebhookRequest {
    /**
     * the owner of the submission
     * @type {string}
     * @memberof SubmissionCompleteWebhookRequest
     */
    'owner'?: string;
    /**
     * the title of the submission
     * @type {string}
     * @memberof SubmissionCompleteWebhookRequest
     */
    'title'?: string;
    /**
     * the current status of the Submission
     * @type {string}
     * @memberof SubmissionCompleteWebhookRequest
     */
    'status'?: SubmissionCompleteWebhookRequestStatusEnum;
    /**
     * the unique ID of the submission
     * @type {string}
     * @memberof SubmissionCompleteWebhookRequest
     */
    'id'?: string;
    /**
     * the content type of the submission
     * @type {string}
     * @memberof SubmissionCompleteWebhookRequest
     */
    'content_type'?: string;
    /**
     * the number of pages in the submission
     * @type {number}
     * @memberof SubmissionCompleteWebhookRequest
     */
    'page_count'?: number;
    /**
     * the number of words in the submission
     * @type {number}
     * @memberof SubmissionCompleteWebhookRequest
     */
    'word_count'?: number;
    /**
     * the number of characters in the submission
     * @type {number}
     * @memberof SubmissionCompleteWebhookRequest
     */
    'character_count'?: number;
    /**
     * an error code representing the type of error encountered (if applicable) 
     * @type {string}
     * @memberof SubmissionCompleteWebhookRequest
     */
    'error_code'?: SubmissionCompleteWebhookRequestErrorCodeEnum;
    /**
     * RFC3339 timestamp of when this submission was initially created. This is the time at which the POST to /submissions was made. 
     * @type {string}
     * @memberof SubmissionCompleteWebhookRequest
     */
    'created_time'?: string;
    /**
     * Set of capabilities available to the current submission
     * @type {Array<string>}
     * @memberof SubmissionCompleteWebhookRequest
     */
    'capabilities'?: Array<SubmissionCompleteWebhookRequestCapabilitiesEnum>;
    /**
     * 
     * @type {SubmissionCompleteWebhookRequestAllOfMetadata}
     * @memberof SubmissionCompleteWebhookRequest
     */
    'metadata'?: SubmissionCompleteWebhookRequestAllOfMetadata;
}

/**
    * @export
    * @enum {string}
    */
export enum SubmissionCompleteWebhookRequestStatusEnum {
    Created = 'CREATED',
    Processing = 'PROCESSING',
    Completed = 'COMPLETED'
}
/**
    * @export
    * @enum {string}
    */
export enum SubmissionCompleteWebhookRequestErrorCodeEnum {
    UnsupportedFiletype = 'UNSUPPORTED_FILETYPE',
    ProcessingError = 'PROCESSING_ERROR',
    CannotExtractText = 'CANNOT_EXTRACT_TEXT',
    TooLittleText = 'TOO_LITTLE_TEXT',
    TooMuchText = 'TOO_MUCH_TEXT',
    TooManyPages = 'TOO_MANY_PAGES',
    FileLocked = 'FILE_LOCKED',
    CorruptFile = 'CORRUPT_FILE'
}
/**
    * @export
    * @enum {string}
    */
export enum SubmissionCompleteWebhookRequestCapabilitiesEnum {
    Index = 'INDEX',
    Similarity = 'SIMILARITY',
    Viewer = 'VIEWER'
}

/**
 * 
 * @export
 * @interface SubmissionCompleteWebhookRequestAllOf
 */
export interface SubmissionCompleteWebhookRequestAllOf {
    /**
     * 
     * @type {SubmissionCompleteWebhookRequestAllOfMetadata}
     * @memberof SubmissionCompleteWebhookRequestAllOf
     */
    'metadata'?: SubmissionCompleteWebhookRequestAllOfMetadata;
}
/**
 * 
 * @export
 * @interface SubmissionCompleteWebhookRequestAllOfMetadata
 */
export interface SubmissionCompleteWebhookRequestAllOfMetadata {
    /**
     * 
     * @type {string}
     * @memberof SubmissionCompleteWebhookRequestAllOfMetadata
     */
    'custom'?: string;
}
/**
 * 
 * @export
 * @interface SubmissionSizeError
 */
export interface SubmissionSizeError {
    /**
     * an HTTP Response JobStatus Code
     * @type {string}
     * @memberof SubmissionSizeError
     */
    'status'?: string;
    /**
     * A message explaining what happened
     * @type {string}
     * @memberof SubmissionSizeError
     */
    'message'?: string;
}
/**
 * Object returned for success messages.
 * @export
 * @interface SuccessMessage
 */
export interface SuccessMessage {
    /**
     * message indicating a successful PUT request
     * @type {string}
     * @memberof SuccessMessage
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * (required) 
     * @type {string}
     * @memberof Users
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'family_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'given_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface ViewerPermissions
 */
export interface ViewerPermissions {
    /**
     * Optional individual permission which override the default permission set.
     * @type {boolean}
     * @memberof ViewerPermissions
     */
    'may_view_submission_full_source'?: boolean;
    /**
     * Optional individual permission which override the default permission set.
     * @type {boolean}
     * @memberof ViewerPermissions
     */
    'may_view_match_submission_info'?: boolean;
    /**
     * Optional individual permission which override the default permission set
     * @type {boolean}
     * @memberof ViewerPermissions
     */
    'may_view_flags_panel'?: boolean;
    /**
     * Optional individual permission which override the default permission set
     * @type {boolean}
     * @memberof ViewerPermissions
     */
    'may_view_document_details_panel'?: boolean;
    /**
     * Optional individual permission which override the default permission set
     * @type {boolean}
     * @memberof ViewerPermissions
     */
    'may_view_sections_exclusion_panel'?: boolean;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * unique id of webhook
     * @type {string}
     * @memberof Webhook
     */
    'id': string;
    /**
     * RFC3339  timestamp of when this Webhook was initially created. This is the time at which the POST to /webhooks was made. 
     * @type {string}
     * @memberof Webhook
     */
    'created_time'?: string;
    /**
     * a human readable description of the webhook
     * @type {string}
     * @memberof Webhook
     */
    'description'?: string;
    /**
     * the URL to callback with events, this must be https unless (allow_insecure is true)
     * @type {string}
     * @memberof Webhook
     */
    'url': string;
    /**
     * if using an non https url, this must be set to true
     * @type {boolean}
     * @memberof Webhook
     */
    'allow_insecure'?: boolean;
    /**
     * an array of the types of callbacks that will be sent to this webhook
     * @type {Array<string>}
     * @memberof Webhook
     */
    'event_types': Array<WebhookEventTypesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookEventTypesEnum {
    SubmissionComplete = 'SUBMISSION_COMPLETE',
    SimilarityComplete = 'SIMILARITY_COMPLETE',
    SimilarityUpdated = 'SIMILARITY_UPDATED',
    PdfStatus = 'PDF_STATUS',
    GroupAttachmentComplete = 'GROUP_ATTACHMENT_COMPLETE'
}

/**
 * 
 * @export
 * @interface WebhookAllOf
 */
export interface WebhookAllOf {
    /**
     * unique id of webhook
     * @type {string}
     * @memberof WebhookAllOf
     */
    'id': string;
    /**
     * RFC3339  timestamp of when this Webhook was initially created. This is the time at which the POST to /webhooks was made. 
     * @type {string}
     * @memberof WebhookAllOf
     */
    'created_time'?: string;
}
/**
 * 
 * @export
 * @interface WebhookBase
 */
export interface WebhookBase {
    /**
     * a human readable description of the webhook
     * @type {string}
     * @memberof WebhookBase
     */
    'description'?: string;
    /**
     * the URL to callback with events, this must be https unless (allow_insecure is true)
     * @type {string}
     * @memberof WebhookBase
     */
    'url': string;
    /**
     * if using an non https url, this must be set to true
     * @type {boolean}
     * @memberof WebhookBase
     */
    'allow_insecure'?: boolean;
    /**
     * an array of the types of callbacks that will be sent to this webhook
     * @type {Array<string>}
     * @memberof WebhookBase
     */
    'event_types': Array<WebhookBaseEventTypesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookBaseEventTypesEnum {
    SubmissionComplete = 'SUBMISSION_COMPLETE',
    SimilarityComplete = 'SIMILARITY_COMPLETE',
    SimilarityUpdated = 'SIMILARITY_UPDATED',
    PdfStatus = 'PDF_STATUS',
    GroupAttachmentComplete = 'GROUP_ATTACHMENT_COMPLETE'
}

/**
 * 
 * @export
 * @interface WebhookPathRequest
 */
export interface WebhookPathRequest {
    /**
     * a human readable description of the webhook
     * @type {string}
     * @memberof WebhookPathRequest
     */
    'description'?: string;
    /**
     * an array of the types of callbacks that will be sent to this webhook
     * @type {Array<string>}
     * @memberof WebhookPathRequest
     */
    'event_types': Array<WebhookPathRequestEventTypesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookPathRequestEventTypesEnum {
    SubmissionComplete = 'SUBMISSION_COMPLETE',
    SimilarityComplete = 'SIMILARITY_COMPLETE',
    SimilarityUpdated = 'SIMILARITY_UPDATED',
    PdfStatus = 'PDF_STATUS',
    GroupAttachmentComplete = 'GROUP_ATTACHMENT_COMPLETE'
}

/**
 * 
 * @export
 * @interface WebhookWithSecret
 */
export interface WebhookWithSecret {
    /**
     * a sercret used to sign all callbacks for this webhook
     * @type {File}
     * @memberof WebhookWithSecret
     */
    'signing_secret': File;
    /**
     * a human readable description of the webhook
     * @type {string}
     * @memberof WebhookWithSecret
     */
    'description'?: string;
    /**
     * the URL to callback with events, this must be https unless (allow_insecure is true)
     * @type {string}
     * @memberof WebhookWithSecret
     */
    'url': string;
    /**
     * if using an non https url, this must be set to true
     * @type {boolean}
     * @memberof WebhookWithSecret
     */
    'allow_insecure'?: boolean;
    /**
     * an array of the types of callbacks that will be sent to this webhook
     * @type {Array<string>}
     * @memberof WebhookWithSecret
     */
    'event_types': Array<WebhookWithSecretEventTypesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookWithSecretEventTypesEnum {
    SubmissionComplete = 'SUBMISSION_COMPLETE',
    SimilarityComplete = 'SIMILARITY_COMPLETE',
    SimilarityUpdated = 'SIMILARITY_UPDATED',
    PdfStatus = 'PDF_STATUS',
    GroupAttachmentComplete = 'GROUP_ATTACHMENT_COMPLETE'
}

/**
 * 
 * @export
 * @interface WebhookWithSecretAllOf
 */
export interface WebhookWithSecretAllOf {
    /**
     * a sercret used to sign all callbacks for this webhook
     * @type {File}
     * @memberof WebhookWithSecretAllOf
     */
    'signing_secret': File;
}

/**
 * EULAApi - axios parameter creator
 * @export
 */
export const EULAApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accepts a particular EULA version on behalf of an external user
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
         * @param {EulaAcceptRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eulaVersionIdAcceptPost: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, data: EulaAcceptRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('eulaVersionIdAcceptPost', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('eulaVersionIdAcceptPost', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('eulaVersionIdAcceptPost', 'versionId', versionId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('eulaVersionIdAcceptPost', 'data', data)
            const localVarPath = `/eula/{version_id}/accept`
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Queries the acceptences of a particular EULA version on behalf of an external user
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
         * @param {string} userId The user associated with the EULA status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eulaVersionIdAcceptUserIdGet: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('eulaVersionIdAcceptUserIdGet', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('eulaVersionIdAcceptUserIdGet', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('eulaVersionIdAcceptUserIdGet', 'versionId', versionId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('eulaVersionIdAcceptUserIdGet', 'userId', userId)
            const localVarPath = `/eula/{version_id}/accept/{user_id}`
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets information about a particular EULA version
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
         * @param {string} [lang] The desired language of the specified EULA version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eulaVersionIdGet: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, lang?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('eulaVersionIdGet', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('eulaVersionIdGet', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('eulaVersionIdGet', 'versionId', versionId)
            const localVarPath = `/eula/{version_id}`
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the text of a particular EULA version
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
         * @param {string} [lang] The desired language of the specified EULA version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eulaVersionIdViewGet: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, lang?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('eulaVersionIdViewGet', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('eulaVersionIdViewGet', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('eulaVersionIdViewGet', 'versionId', versionId)
            const localVarPath = `/eula/{version_id}/view`
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EULAApi - functional programming interface
 * @export
 */
export const EULAApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EULAApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accepts a particular EULA version on behalf of an external user
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
         * @param {EulaAcceptRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eulaVersionIdAcceptPost(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, data: EulaAcceptRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EulaAcceptListItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eulaVersionIdAcceptPost(xTurnitinIntegrationName, xTurnitinIntegrationVersion, versionId, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Queries the acceptences of a particular EULA version on behalf of an external user
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
         * @param {string} userId The user associated with the EULA status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eulaVersionIdAcceptUserIdGet(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EulaAcceptListItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eulaVersionIdAcceptUserIdGet(xTurnitinIntegrationName, xTurnitinIntegrationVersion, versionId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets information about a particular EULA version
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
         * @param {string} [lang] The desired language of the specified EULA version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eulaVersionIdGet(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, lang?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EulaVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eulaVersionIdGet(xTurnitinIntegrationName, xTurnitinIntegrationVersion, versionId, lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the text of a particular EULA version
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
         * @param {string} [lang] The desired language of the specified EULA version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eulaVersionIdViewGet(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, lang?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eulaVersionIdViewGet(xTurnitinIntegrationName, xTurnitinIntegrationVersion, versionId, lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EULAApi - factory interface
 * @export
 */
export const EULAApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EULAApiFp(configuration)
    return {
        /**
         * 
         * @summary Accepts a particular EULA version on behalf of an external user
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
         * @param {EulaAcceptRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eulaVersionIdAcceptPost(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, data: EulaAcceptRequest, options?: any): AxiosPromise<EulaAcceptListItem> {
            return localVarFp.eulaVersionIdAcceptPost(xTurnitinIntegrationName, xTurnitinIntegrationVersion, versionId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Queries the acceptences of a particular EULA version on behalf of an external user
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
         * @param {string} userId The user associated with the EULA status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eulaVersionIdAcceptUserIdGet(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, userId: string, options?: any): AxiosPromise<Array<EulaAcceptListItem>> {
            return localVarFp.eulaVersionIdAcceptUserIdGet(xTurnitinIntegrationName, xTurnitinIntegrationVersion, versionId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets information about a particular EULA version
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
         * @param {string} [lang] The desired language of the specified EULA version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eulaVersionIdGet(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, lang?: string, options?: any): AxiosPromise<EulaVersion> {
            return localVarFp.eulaVersionIdGet(xTurnitinIntegrationName, xTurnitinIntegrationVersion, versionId, lang, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the text of a particular EULA version
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
         * @param {string} [lang] The desired language of the specified EULA version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eulaVersionIdViewGet(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, lang?: string, options?: any): AxiosPromise<string> {
            return localVarFp.eulaVersionIdViewGet(xTurnitinIntegrationName, xTurnitinIntegrationVersion, versionId, lang, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EULAApi - object-oriented interface
 * @export
 * @class EULAApi
 * @extends {BaseAPI}
 */
export class EULAApi extends BaseAPI {
    /**
     * 
     * @summary Accepts a particular EULA version on behalf of an external user
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
     * @param {EulaAcceptRequest} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EULAApi
     */
    public eulaVersionIdAcceptPost(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, data: EulaAcceptRequest, options?: AxiosRequestConfig) {
        return EULAApiFp(this.configuration).eulaVersionIdAcceptPost(xTurnitinIntegrationName, xTurnitinIntegrationVersion, versionId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Queries the acceptences of a particular EULA version on behalf of an external user
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
     * @param {string} userId The user associated with the EULA status 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EULAApi
     */
    public eulaVersionIdAcceptUserIdGet(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, userId: string, options?: AxiosRequestConfig) {
        return EULAApiFp(this.configuration).eulaVersionIdAcceptUserIdGet(xTurnitinIntegrationName, xTurnitinIntegrationVersion, versionId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets information about a particular EULA version
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
     * @param {string} [lang] The desired language of the specified EULA version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EULAApi
     */
    public eulaVersionIdGet(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, lang?: string, options?: AxiosRequestConfig) {
        return EULAApiFp(this.configuration).eulaVersionIdGet(xTurnitinIntegrationName, xTurnitinIntegrationVersion, versionId, lang, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the text of a particular EULA version
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} versionId The EULA version ID (or &#x60;latest&#x60;) 
     * @param {string} [lang] The desired language of the specified EULA version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EULAApi
     */
    public eulaVersionIdViewGet(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, versionId: string, lang?: string, options?: AxiosRequestConfig) {
        return EULAApiFp(this.configuration).eulaVersionIdViewGet(xTurnitinIntegrationName, xTurnitinIntegrationVersion, versionId, lang, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeaturesApi - axios parameter creator
 * @export
 */
export const FeaturesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get information about what features are allowed by the current license
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        featuresEnabledGet: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('featuresEnabledGet', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('featuresEnabledGet', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            const localVarPath = `/features-enabled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeaturesApi - functional programming interface
 * @export
 */
export const FeaturesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeaturesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get information about what features are allowed by the current license
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async featuresEnabledGet(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeaturesEnabled>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.featuresEnabledGet(xTurnitinIntegrationName, xTurnitinIntegrationVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeaturesApi - factory interface
 * @export
 */
export const FeaturesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeaturesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get information about what features are allowed by the current license
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        featuresEnabledGet(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, options?: any): AxiosPromise<FeaturesEnabled> {
            return localVarFp.featuresEnabledGet(xTurnitinIntegrationName, xTurnitinIntegrationVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeaturesApi - object-oriented interface
 * @export
 * @class FeaturesApi
 * @extends {BaseAPI}
 */
export class FeaturesApi extends BaseAPI {
    /**
     * 
     * @summary Get information about what features are allowed by the current license
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeaturesApi
     */
    public featuresEnabledGet(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, options?: AxiosRequestConfig) {
        return FeaturesApiFp(this.configuration).featuresEnabledGet(xTurnitinIntegrationName, xTurnitinIntegrationVersion, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add attachment to a group. will create a group if it does not exist.
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {AddGroupAttachmentRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupAttachment: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, data: AddGroupAttachmentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('addGroupAttachment', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('addGroupAttachment', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('addGroupAttachment', 'groupId', groupId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('addGroupAttachment', 'data', data)
            const localVarPath = `/groups/{group_id}/attachments`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Hard delete group attachment
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupAttachment: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('deleteGroupAttachment', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('deleteGroupAttachment', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroupAttachment', 'groupId', groupId)
            // verify required parameter 'attachId' is not null or undefined
            assertParamExists('deleteGroupAttachment', 'attachId', attachId)
            const localVarPath = `/groups/{group_id}/attachments/{attach_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"attach_id"}}`, encodeURIComponent(String(attachId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get group, group context and group context owners info
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('getGroup', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('getGroup', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroup', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get group attachment
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAttachment: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('getGroupAttachment', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('getGroupAttachment', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupAttachment', 'groupId', groupId)
            // verify required parameter 'attachId' is not null or undefined
            assertParamExists('getGroupAttachment', 'attachId', attachId)
            const localVarPath = `/groups/{group_id}/attachments/{attach_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"attach_id"}}`, encodeURIComponent(String(attachId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all attachments
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAttachments: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('getGroupAttachments', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('getGroupAttachments', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupAttachments', 'groupId', groupId)
            const localVarPath = `/groups/{group_id}/attachments`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary upsert group, group context and group context owners info
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {AggregateGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdPut: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, data: AggregateGroup, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('groupsGroupIdPut', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('groupsGroupIdPut', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsGroupIdPut', 'groupId', groupId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('groupsGroupIdPut', 'data', data)
            const localVarPath = `/groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch a group attachment
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
         * @param {AddGroupAttachmentRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupAttachment: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, data: AddGroupAttachmentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('updateGroupAttachment', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('updateGroupAttachment', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroupAttachment', 'groupId', groupId)
            // verify required parameter 'attachId' is not null or undefined
            assertParamExists('updateGroupAttachment', 'attachId', attachId)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('updateGroupAttachment', 'data', data)
            const localVarPath = `/groups/{group_id}/attachments/{attach_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"attach_id"}}`, encodeURIComponent(String(attachId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Submitted File
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId The Group ID (required to already exist) 
         * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
         * @param {string} contentDisposition *must include the \&quot;filename\&quot; parameter, e.g. &#x60;inline; filename&#x3D;\&quot;MyFile.docx\&quot;&#x60; 
         * @param {object} file the attachment file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGroupAttachment: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, contentDisposition: string, file: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('uploadGroupAttachment', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('uploadGroupAttachment', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('uploadGroupAttachment', 'groupId', groupId)
            // verify required parameter 'attachId' is not null or undefined
            assertParamExists('uploadGroupAttachment', 'attachId', attachId)
            // verify required parameter 'contentDisposition' is not null or undefined
            assertParamExists('uploadGroupAttachment', 'contentDisposition', contentDisposition)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadGroupAttachment', 'file', file)
            const localVarPath = `/groups/{group_id}/attachments/{attach_id}/original`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"attach_id"}}`, encodeURIComponent(String(attachId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }

            if (contentDisposition != null) {
                localVarHeaderParameter['Content-Disposition'] = String(contentDisposition);
            }


    
            localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(file, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add attachment to a group. will create a group if it does not exist.
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {AddGroupAttachmentRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGroupAttachment(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, data: AddGroupAttachmentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddGroupAttachmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupAttachment(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Hard delete group attachment
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupAttachment(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupAttachment(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, attachId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get group, group context and group context owners info
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AggregateGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get group attachment
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupAttachment(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupAttachmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupAttachment(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, attachId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all attachments
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupAttachments(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGroupAttachments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupAttachments(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary upsert group, group context and group context owners info
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {AggregateGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGroupIdPut(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, data: AggregateGroup, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AggregateGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGroupIdPut(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Patch a group attachment
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
         * @param {AddGroupAttachmentRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupAttachment(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, data: AddGroupAttachmentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupAttachmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupAttachment(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, attachId, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload Submitted File
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId The Group ID (required to already exist) 
         * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
         * @param {string} contentDisposition *must include the \&quot;filename\&quot; parameter, e.g. &#x60;inline; filename&#x3D;\&quot;MyFile.docx\&quot;&#x60; 
         * @param {object} file the attachment file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadGroupAttachment(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, contentDisposition: string, file: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadGroupAttachment(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, attachId, contentDisposition, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add attachment to a group. will create a group if it does not exist.
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {AddGroupAttachmentRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroupAttachment(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, data: AddGroupAttachmentRequest, options?: any): AxiosPromise<AddGroupAttachmentResponse> {
            return localVarFp.addGroupAttachment(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Hard delete group attachment
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupAttachment(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroupAttachment(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, attachId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get group, group context and group context owners info
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, options?: any): AxiosPromise<AggregateGroup> {
            return localVarFp.getGroup(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get group attachment
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAttachment(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, options?: any): AxiosPromise<GroupAttachmentResponse> {
            return localVarFp.getGroupAttachment(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, attachId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all attachments
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAttachments(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, options?: any): AxiosPromise<GetGroupAttachments200Response> {
            return localVarFp.getGroupAttachments(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary upsert group, group context and group context owners info
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {AggregateGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdPut(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, data: AggregateGroup, options?: any): AxiosPromise<AggregateGroup> {
            return localVarFp.groupsGroupIdPut(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch a group attachment
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId group_id
         * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
         * @param {AddGroupAttachmentRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupAttachment(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, data: AddGroupAttachmentRequest, options?: any): AxiosPromise<GroupAttachmentResponse> {
            return localVarFp.updateGroupAttachment(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, attachId, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Submitted File
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} groupId The Group ID (required to already exist) 
         * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
         * @param {string} contentDisposition *must include the \&quot;filename\&quot; parameter, e.g. &#x60;inline; filename&#x3D;\&quot;MyFile.docx\&quot;&#x60; 
         * @param {object} file the attachment file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGroupAttachment(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, contentDisposition: string, file: object, options?: any): AxiosPromise<SuccessMessage> {
            return localVarFp.uploadGroupAttachment(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, attachId, contentDisposition, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * 
     * @summary Add attachment to a group. will create a group if it does not exist.
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} groupId group_id
     * @param {AddGroupAttachmentRequest} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public addGroupAttachment(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, data: AddGroupAttachmentRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).addGroupAttachment(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Hard delete group attachment
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} groupId group_id
     * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroupAttachment(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroupAttachment(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, attachId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get group, group context and group context owners info
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} groupId group_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroup(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroup(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get group attachment
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} groupId group_id
     * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupAttachment(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupAttachment(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, attachId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all attachments
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} groupId group_id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupAttachments(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupAttachments(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary upsert group, group context and group context owners info
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} groupId group_id
     * @param {AggregateGroup} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGroupIdPut(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, data: AggregateGroup, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsGroupIdPut(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch a group attachment
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} groupId group_id
     * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
     * @param {AddGroupAttachmentRequest} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupAttachment(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, data: AddGroupAttachmentRequest, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroupAttachment(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, attachId, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Submitted File
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} groupId The Group ID (required to already exist) 
     * @param {string} attachId The attachment ID (returned from a successful group attachment request) 
     * @param {string} contentDisposition *must include the \&quot;filename\&quot; parameter, e.g. &#x60;inline; filename&#x3D;\&quot;MyFile.docx\&quot;&#x60; 
     * @param {object} file the attachment file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public uploadGroupAttachment(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, groupId: string, attachId: string, contentDisposition: string, file: object, options?: AxiosRequestConfig) {
        return GroupsApiFp(this.configuration).uploadGroupAttachment(xTurnitinIntegrationName, xTurnitinIntegrationVersion, groupId, attachId, contentDisposition, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IndexApi - axios parameter creator
 * @export
 */
export const IndexApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return index state of submission
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexStatus: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('getIndexStatus', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('getIndexStatus', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIndexStatus', 'id', id)
            const localVarPath = `/submissions/{id}/index`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Index and return index state of submission
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexSubmission: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('indexSubmission', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('indexSubmission', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('indexSubmission', 'id', id)
            const localVarPath = `/submissions/{id}/index`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IndexApi - functional programming interface
 * @export
 */
export const IndexApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IndexApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Return index state of submission
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIndexStatus(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IndexStateSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIndexStatus(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Index and return index state of submission
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async indexSubmission(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IndexStateSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.indexSubmission(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IndexApi - factory interface
 * @export
 */
export const IndexApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IndexApiFp(configuration)
    return {
        /**
         * 
         * @summary Return index state of submission
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIndexStatus(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: any): AxiosPromise<IndexStateSettings> {
            return localVarFp.getIndexStatus(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Index and return index state of submission
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexSubmission(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: any): AxiosPromise<IndexStateSettings> {
            return localVarFp.indexSubmission(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IndexApi - object-oriented interface
 * @export
 * @class IndexApi
 * @extends {BaseAPI}
 */
export class IndexApi extends BaseAPI {
    /**
     * 
     * @summary Return index state of submission
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexApi
     */
    public getIndexStatus(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig) {
        return IndexApiFp(this.configuration).getIndexStatus(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Index and return index state of submission
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IndexApi
     */
    public indexSubmission(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig) {
        return IndexApiFp(this.configuration).indexSubmission(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SimilarityApi - axios parameter creator
 * @export
 */
export const SimilarityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary GET download pdf
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {string} pdfId The Pdf ID (returned upon a successful POST to /submissions/{submission_id}/similarity/pdf) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSimilarityReportPdf: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, pdfId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('downloadSimilarityReportPdf', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('downloadSimilarityReportPdf', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadSimilarityReportPdf', 'id', id)
            // verify required parameter 'pdfId' is not null or undefined
            assertParamExists('downloadSimilarityReportPdf', 'pdfId', pdfId)
            const localVarPath = `/submissions/{id}/similarity/pdf/{pdf_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pdf_id"}}`, encodeURIComponent(String(pdfId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GET pdf download status
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {string} pdfId The Pdf ID (returned upon a successful POST to /submissions/{submission_id}/similarity/pdf) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarityReportPdfStatus: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, pdfId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('getSimilarityReportPdfStatus', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('getSimilarityReportPdfStatus', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSimilarityReportPdfStatus', 'id', id)
            // verify required parameter 'pdfId' is not null or undefined
            assertParamExists('getSimilarityReportPdfStatus', 'pdfId', pdfId)
            const localVarPath = `/submissions/{id}/similarity/pdf/{pdf_id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"pdf_id"}}`, encodeURIComponent(String(pdfId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Similarity Report Results
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarityReportResults: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('getSimilarityReportResults', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('getSimilarityReportResults', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSimilarityReportResults', 'id', id)
            const localVarPath = `/submissions/{id}/similarity`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a URL to access Cloud Viewer
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {SimilarityViewerUrlSettings} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarityReportUrl: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, data: SimilarityViewerUrlSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('getSimilarityReportUrl', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('getSimilarityReportUrl', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSimilarityReportUrl', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getSimilarityReportUrl', 'data', data)
            const localVarPath = `/submissions/{id}/viewer-url`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Similarity Report generation
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {SimilarityPutRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestSimilarityReport: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, data: SimilarityPutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('requestSimilarityReport', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('requestSimilarityReport', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('requestSimilarityReport', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('requestSimilarityReport', 'data', data)
            const localVarPath = `/submissions/{id}/similarity`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Pdf download and returns the Pdf Id
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestSimilarityReportPdf: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('requestSimilarityReportPdf', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('requestSimilarityReportPdf', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('requestSimilarityReportPdf', 'id', id)
            const localVarPath = `/submissions/{id}/similarity/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SimilarityApi - functional programming interface
 * @export
 */
export const SimilarityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SimilarityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary GET download pdf
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {string} pdfId The Pdf ID (returned upon a successful POST to /submissions/{submission_id}/similarity/pdf) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSimilarityReportPdf(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, pdfId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSimilarityReportPdf(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, pdfId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary GET pdf download status
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {string} pdfId The Pdf ID (returned upon a successful POST to /submissions/{submission_id}/similarity/pdf) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarityReportPdfStatus(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, pdfId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PdfStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimilarityReportPdfStatus(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, pdfId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Similarity Report Results
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarityReportResults(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimilarityMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimilarityReportResults(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a URL to access Cloud Viewer
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {SimilarityViewerUrlSettings} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarityReportUrl(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, data: SimilarityViewerUrlSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimilarityViewerUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimilarityReportUrl(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request Similarity Report generation
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {SimilarityPutRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestSimilarityReport(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, data: SimilarityPutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestSimilarityReport(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request Pdf download and returns the Pdf Id
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestSimilarityReportPdf(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestPdfResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestSimilarityReportPdf(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SimilarityApi - factory interface
 * @export
 */
export const SimilarityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SimilarityApiFp(configuration)
    return {
        /**
         * 
         * @summary GET download pdf
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {string} pdfId The Pdf ID (returned upon a successful POST to /submissions/{submission_id}/similarity/pdf) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSimilarityReportPdf(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, pdfId: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadSimilarityReportPdf(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, pdfId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GET pdf download status
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {string} pdfId The Pdf ID (returned upon a successful POST to /submissions/{submission_id}/similarity/pdf) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarityReportPdfStatus(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, pdfId: string, options?: any): AxiosPromise<PdfStatusResponse> {
            return localVarFp.getSimilarityReportPdfStatus(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, pdfId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Similarity Report Results
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarityReportResults(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: any): AxiosPromise<SimilarityMetadata> {
            return localVarFp.getSimilarityReportResults(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a URL to access Cloud Viewer
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {SimilarityViewerUrlSettings} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarityReportUrl(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, data: SimilarityViewerUrlSettings, options?: any): AxiosPromise<SimilarityViewerUrlResponse> {
            return localVarFp.getSimilarityReportUrl(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Similarity Report generation
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {SimilarityPutRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestSimilarityReport(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, data: SimilarityPutRequest, options?: any): AxiosPromise<SuccessMessage> {
            return localVarFp.requestSimilarityReport(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Pdf download and returns the Pdf Id
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestSimilarityReportPdf(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: any): AxiosPromise<RequestPdfResponse> {
            return localVarFp.requestSimilarityReportPdf(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SimilarityApi - object-oriented interface
 * @export
 * @class SimilarityApi
 * @extends {BaseAPI}
 */
export class SimilarityApi extends BaseAPI {
    /**
     * 
     * @summary GET download pdf
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
     * @param {string} pdfId The Pdf ID (returned upon a successful POST to /submissions/{submission_id}/similarity/pdf) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimilarityApi
     */
    public downloadSimilarityReportPdf(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, pdfId: string, options?: AxiosRequestConfig) {
        return SimilarityApiFp(this.configuration).downloadSimilarityReportPdf(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, pdfId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GET pdf download status
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
     * @param {string} pdfId The Pdf ID (returned upon a successful POST to /submissions/{submission_id}/similarity/pdf) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimilarityApi
     */
    public getSimilarityReportPdfStatus(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, pdfId: string, options?: AxiosRequestConfig) {
        return SimilarityApiFp(this.configuration).getSimilarityReportPdfStatus(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, pdfId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Similarity Report Results
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimilarityApi
     */
    public getSimilarityReportResults(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig) {
        return SimilarityApiFp(this.configuration).getSimilarityReportResults(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a URL to access Cloud Viewer
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
     * @param {SimilarityViewerUrlSettings} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimilarityApi
     */
    public getSimilarityReportUrl(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, data: SimilarityViewerUrlSettings, options?: AxiosRequestConfig) {
        return SimilarityApiFp(this.configuration).getSimilarityReportUrl(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Similarity Report generation
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
     * @param {SimilarityPutRequest} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimilarityApi
     */
    public requestSimilarityReport(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, data: SimilarityPutRequest, options?: AxiosRequestConfig) {
        return SimilarityApiFp(this.configuration).requestSimilarityReport(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Pdf download and returns the Pdf Id
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimilarityApi
     */
    public requestSimilarityReportPdf(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig) {
        return SimilarityApiFp(this.configuration).requestSimilarityReportPdf(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubmissionApi - axios parameter creator
 * @export
 */
export const SubmissionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Submission
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {SubmissionBase} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubmission: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, data: SubmissionBase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('createSubmission', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('createSubmission', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('createSubmission', 'data', data)
            const localVarPath = `/submissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a submission and associated similarity report.
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {string} [hard] Accepts true or false indicating either hard or soft delete. A soft delete removes the associated submission report/index and changes the saved submission state to DELETED. A hard deletion completely removes the submission information from Panda and TCA and removes the associated report/index, which can not be recovered. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmission: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, hard?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('deleteSubmission', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('deleteSubmission', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSubmission', 'id', id)
            const localVarPath = `/submissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (hard !== undefined) {
                localVarQueryParameter['hard'] = hard;
            }

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Submission Details
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmiddionDetails: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('getSubmiddionDetails', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('getSubmiddionDetails', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubmiddionDetails', 'id', id)
            const localVarPath = `/submissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Recover a soft deleted submission
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverSubmission: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('recoverSubmission', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('recoverSubmission', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('recoverSubmission', 'id', id)
            const localVarPath = `/submissions/{id}/recover`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Submitted File
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {string} contentType *Must be \&#39;binary/octet-stream\&#39; 
         * @param {string} contentDisposition *must include the \&quot;filename\&quot; parameter, e.g. &#x60;inline; filename&#x3D;\&quot;MyFile.docx\&quot;&#x60;. To support UTF-8 filenames, you must URL encode the header 
         * @param {object} file the user\&#39;s submitted file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSubmittedFile: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, contentType: string, contentDisposition: string, file: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('uploadSubmittedFile', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('uploadSubmittedFile', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadSubmittedFile', 'id', id)
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('uploadSubmittedFile', 'contentType', contentType)
            // verify required parameter 'contentDisposition' is not null or undefined
            assertParamExists('uploadSubmittedFile', 'contentDisposition', contentDisposition)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadSubmittedFile', 'file', file)
            const localVarPath = `/submissions/{id}/original`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }

            if (contentType != null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (contentDisposition != null) {
                localVarHeaderParameter['Content-Disposition'] = String(contentDisposition);
            }


    
            localVarHeaderParameter['Content-Type'] = 'binary/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(file, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmissionApi - functional programming interface
 * @export
 */
export const SubmissionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubmissionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Submission
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {SubmissionBase} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubmission(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, data: SubmissionBase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleSubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubmission(xTurnitinIntegrationName, xTurnitinIntegrationVersion, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a submission and associated similarity report.
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {string} [hard] Accepts true or false indicating either hard or soft delete. A soft delete removes the associated submission report/index and changes the saved submission state to DELETED. A hard deletion completely removes the submission information from Panda and TCA and removes the associated report/index, which can not be recovered. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubmission(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, hard?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubmission(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, hard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Submission Details
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubmiddionDetails(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Submission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubmiddionDetails(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Recover a soft deleted submission
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoverSubmission(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleSubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoverSubmission(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload Submitted File
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {string} contentType *Must be \&#39;binary/octet-stream\&#39; 
         * @param {string} contentDisposition *must include the \&quot;filename\&quot; parameter, e.g. &#x60;inline; filename&#x3D;\&quot;MyFile.docx\&quot;&#x60;. To support UTF-8 filenames, you must URL encode the header 
         * @param {object} file the user\&#39;s submitted file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadSubmittedFile(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, contentType: string, contentDisposition: string, file: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadSubmittedFile(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, contentType, contentDisposition, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubmissionApi - factory interface
 * @export
 */
export const SubmissionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubmissionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Submission
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {SubmissionBase} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubmission(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, data: SubmissionBase, options?: any): AxiosPromise<SimpleSubmissionResponse> {
            return localVarFp.createSubmission(xTurnitinIntegrationName, xTurnitinIntegrationVersion, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a submission and associated similarity report.
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {string} [hard] Accepts true or false indicating either hard or soft delete. A soft delete removes the associated submission report/index and changes the saved submission state to DELETED. A hard deletion completely removes the submission information from Panda and TCA and removes the associated report/index, which can not be recovered. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmission(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, hard?: string, options?: any): AxiosPromise<SuccessMessage> {
            return localVarFp.deleteSubmission(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, hard, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Submission Details
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmiddionDetails(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: any): AxiosPromise<Submission> {
            return localVarFp.getSubmiddionDetails(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Recover a soft deleted submission
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoverSubmission(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: any): AxiosPromise<SimpleSubmissionResponse> {
            return localVarFp.recoverSubmission(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Submitted File
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
         * @param {string} contentType *Must be \&#39;binary/octet-stream\&#39; 
         * @param {string} contentDisposition *must include the \&quot;filename\&quot; parameter, e.g. &#x60;inline; filename&#x3D;\&quot;MyFile.docx\&quot;&#x60;. To support UTF-8 filenames, you must URL encode the header 
         * @param {object} file the user\&#39;s submitted file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSubmittedFile(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, contentType: string, contentDisposition: string, file: object, options?: any): AxiosPromise<SuccessMessage> {
            return localVarFp.uploadSubmittedFile(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, contentType, contentDisposition, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubmissionApi - object-oriented interface
 * @export
 * @class SubmissionApi
 * @extends {BaseAPI}
 */
export class SubmissionApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Submission
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {SubmissionBase} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public createSubmission(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, data: SubmissionBase, options?: AxiosRequestConfig) {
        return SubmissionApiFp(this.configuration).createSubmission(xTurnitinIntegrationName, xTurnitinIntegrationVersion, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a submission and associated similarity report.
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
     * @param {string} [hard] Accepts true or false indicating either hard or soft delete. A soft delete removes the associated submission report/index and changes the saved submission state to DELETED. A hard deletion completely removes the submission information from Panda and TCA and removes the associated report/index, which can not be recovered. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public deleteSubmission(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, hard?: string, options?: AxiosRequestConfig) {
        return SubmissionApiFp(this.configuration).deleteSubmission(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, hard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Submission Details
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public getSubmiddionDetails(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig) {
        return SubmissionApiFp(this.configuration).getSubmiddionDetails(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Recover a soft deleted submission
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public recoverSubmission(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig) {
        return SubmissionApiFp(this.configuration).recoverSubmission(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Submitted File
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} id The Submission ID (returned upon a successful POST to /submissions) 
     * @param {string} contentType *Must be \&#39;binary/octet-stream\&#39; 
     * @param {string} contentDisposition *must include the \&quot;filename\&quot; parameter, e.g. &#x60;inline; filename&#x3D;\&quot;MyFile.docx\&quot;&#x60;. To support UTF-8 filenames, you must URL encode the header 
     * @param {object} file the user\&#39;s submitted file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public uploadSubmittedFile(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, contentType: string, contentDisposition: string, file: object, options?: AxiosRequestConfig) {
        return SubmissionApiFp(this.configuration).uploadSubmittedFile(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, contentType, contentDisposition, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Webhook endpoint
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('deleteWebhook', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('deleteWebhook', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWebhook', 'id', id)
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Webhook endpoint info
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('getWebhook', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('getWebhook', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebhook', 'id', id)
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Webhook endpoint info
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id 
         * @param {WebhookPathRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, data: WebhookPathRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('updateWebhook', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('updateWebhook', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateWebhook', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('updateWebhook', 'data', data)
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List registered Webhook endpoints
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('webhooksGet', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('webhooksGet', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a Webhook endpoint
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {WebhookWithSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost: async (xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, data: WebhookWithSecret, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTurnitinIntegrationName' is not null or undefined
            assertParamExists('webhooksPost', 'xTurnitinIntegrationName', xTurnitinIntegrationName)
            // verify required parameter 'xTurnitinIntegrationVersion' is not null or undefined
            assertParamExists('webhooksPost', 'xTurnitinIntegrationVersion', xTurnitinIntegrationVersion)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('webhooksPost', 'data', data)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (xTurnitinIntegrationName != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Name'] = String(xTurnitinIntegrationName);
            }

            if (xTurnitinIntegrationVersion != null) {
                localVarHeaderParameter['X-Turnitin-Integration-Version'] = String(xTurnitinIntegrationVersion);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Webhook endpoint
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Webhook endpoint info
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Webhook endpoint info
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id 
         * @param {WebhookPathRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, data: WebhookPathRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List registered Webhook endpoints
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksGet(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Webhook>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksGet(xTurnitinIntegrationName, xTurnitinIntegrationVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a Webhook endpoint
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {WebhookWithSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksPost(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, data: WebhookWithSecret, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksPost(xTurnitinIntegrationName, xTurnitinIntegrationVersion, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Webhook endpoint
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWebhook(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Webhook endpoint info
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: any): AxiosPromise<Webhook> {
            return localVarFp.getWebhook(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Webhook endpoint info
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {string} id 
         * @param {WebhookPathRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, data: WebhookPathRequest, options?: any): AxiosPromise<Webhook> {
            return localVarFp.updateWebhook(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List registered Webhook endpoints
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, options?: any): AxiosPromise<Array<Webhook>> {
            return localVarFp.webhooksGet(xTurnitinIntegrationName, xTurnitinIntegrationVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a Webhook endpoint
         * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
         * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
         * @param {WebhookWithSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, data: WebhookWithSecret, options?: any): AxiosPromise<Webhook> {
            return localVarFp.webhooksPost(xTurnitinIntegrationName, xTurnitinIntegrationVersion, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @summary Delete Webhook endpoint
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public deleteWebhook(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).deleteWebhook(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Webhook endpoint info
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public getWebhook(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).getWebhook(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Webhook endpoint info
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {string} id 
     * @param {WebhookPathRequest} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public updateWebhook(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, id: string, data: WebhookPathRequest, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).updateWebhook(xTurnitinIntegrationName, xTurnitinIntegrationVersion, id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List registered Webhook endpoints
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhooksGet(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhooksGet(xTurnitinIntegrationName, xTurnitinIntegrationVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a Webhook endpoint
     * @param {string} xTurnitinIntegrationName a human readable string representing the type of integration being used
     * @param {string} xTurnitinIntegrationVersion the version of the integration platform being used
     * @param {WebhookWithSecret} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhooksPost(xTurnitinIntegrationName: string, xTurnitinIntegrationVersion: string, data: WebhookWithSecret, options?: AxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhooksPost(xTurnitinIntegrationName, xTurnitinIntegrationVersion, data, options).then((request) => request(this.axios, this.basePath));
    }
}


